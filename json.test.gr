import * from "./json"

// Parsing

// Simple values of each type
assert parse("null") == Ok(JSONNull)
assert parse("true") == Ok(JSONBoolean(true))
assert parse("false") == Ok(JSONBoolean(false))
assert parse("\"\"") == Ok(JSONString(""))
assert parse("0") == Ok(JSONNumber(0))
assert parse("[]") == Ok(JSONArray([]))
assert parse("{}") == Ok(JSONObject([]))

// Various strings. Escapes, emojis etc.
assert parse("\"ASCII Hello world!\"") == Ok(JSONString("ASCII Hello world!"))

assert parse("\"Unicode こんにちは世界!\"") ==
Ok(JSONString("Unicode こんにちは世界!"))
assert parse("\"A \\\"quoted\\\" string\"") ==
Ok(JSONString("A \"quoted\" string"))
assert parse("\"🤘🏻\"") == Ok(JSONString("🤘🏻"))
assert parse("\"🤘🏻\"") == Ok(JSONString("🤘🏻"))
assert parse("\"🏴󠁧󠁢󠁷󠁬󠁳󠁿\"") ==
Ok(JSONString("🏴󠁧󠁢󠁷󠁬󠁳󠁿"))

assert parse(
  "\"\u005Cu6000 \u005Cud800\u005Cudc82 \u005Cud83e\u005Cudd18\u005Cud83c\u005Cudffb \u005Cud83c\u005Cudff4\u005Cudb40\u005Cudc67\u005Cudb40\u005Cudc62\u005Cudb40\u005Cudc77\u005Cudb40\u005Cudc6c\u005Cudb40\u005Cudc73\u005Cudb40\u005Cudc7f\"",
) ==
Ok(JSONString("怀 𐂂 🤘🏻 🏴󠁧󠁢󠁷󠁬󠁳󠁿"))

assert parse(
  "\"\u005Cu6000 \u005Cud800\u005Cudc82 \u005Cud83e\u005Cudd18\u005Cud83c\u005Cudffb \u005Cud83c\u005Cudff4\u005Cudb40\u005Cudc67\u005Cudb40\u005Cudc62\u005Cudb40\u005Cudc77\u005Cudb40\u005Cudc6c\u005Cudb40\u005Cudc73\u005Cudb40\u005Cudc7f\"",
) ==
parse("\"怀 𐂂 🤘🏻 🏴󠁧󠁢󠁷󠁬󠁳󠁿\"")

// Different number types and values
assert parse("-10") == Ok(JSONNumber(-10))
assert parse("-2") == Ok(JSONNumber(-2))
assert parse("-1") == Ok(JSONNumber(-1))
assert parse("1") == Ok(JSONNumber(1))
assert parse("2") == Ok(JSONNumber(2))
assert parse("10") == Ok(JSONNumber(10))
assert parse("100") == Ok(JSONNumber(100))
assert parse("1000") == Ok(JSONNumber(1000))
assert parse("0.0") == Ok(JSONNumber(0.0))
assert parse("0.1") == Ok(JSONNumber(0.1))
assert parse("0.123") == Ok(JSONNumber(0.123))
assert parse("0.9") == Ok(JSONNumber(0.9))
assert parse("1.123") == Ok(JSONNumber(1.123))
assert parse("0e0") == Ok(JSONNumber(0.0))
assert parse("1e0") == Ok(JSONNumber(1.0))
assert parse("1e1") == Ok(JSONNumber(10.0))
assert parse("1E1") == Ok(JSONNumber(10.0))
assert parse("1e2") == Ok(JSONNumber(100.0))
assert parse("1e3") == Ok(JSONNumber(1000.0))
assert parse("-1e2") == Ok(JSONNumber(-100.0))
assert parse("1e-1") == Ok(JSONNumber(0.1))
assert parse("1.23e-4") == Ok(JSONNumber(0.000123))

// FIXME
// "-0" currently parses to 0, but should it?
// assert parse("-0") == Ok(JSONNumber(?))
// Note that in Grain these are true:
// assert 0 == 0
// assert 0.0 == -0.0
// assert 0 == -0.0
// And printing constant "-0" results in "0"

// Big numbers
assert parse("1152921504606846976") == Ok(JSONNumber(1152921504606846976))

// TODO Bigger numbers.
// Numbers with large exponents not yet handled in parsing. Waiting for arbitrary precision number support in Grain.
//assert parse("1E200") == Ok(JSONNumber(1E200))
//assert parse("1E-200") == Ok(JSONNumber(1E-200))

// Complex objects and arrays.

assert parse("{ \"Hello\" : \"World!\" }") ==
Ok(JSONObject([("Hello", JSONString("World!"))]))

assert parse("{\"a\":\"A\",\"b\":\"B\"}") ==
Ok(JSONObject([("a", JSONString("A")), ("b", JSONString("B"))]))

assert parse(
  "{ \"a\" : { \"0\": false, \"1\":true }, \"b\" : [\"A\",\"B\",\"C\"] }",
) ==
Ok(
  JSONObject(
    [
      ("a", JSONObject([("0", JSONBoolean(false)), ("1", JSONBoolean(true))])),
      ("b", JSONArray([JSONString("A"), JSONString("B"), JSONString("C")])),
    ],
  ),
)

assert parse("[1,\"2\",true,false,null]") ==
Ok(
  JSONArray(
    [
      JSONNumber(1),
      JSONString("2"),
      JSONBoolean(true),
      JSONBoolean(false),
      JSONNull,
    ],
  ),
)

assert parse("[[[[[[[[[[]]]]]]]]]]") ==
Ok(
  JSONArray(
    [
      JSONArray(
        [
          JSONArray(
            [
              JSONArray(
                [
                  JSONArray(
                    [
                      JSONArray(
                        [JSONArray([JSONArray([JSONArray([JSONArray([])])])])],
                      ),
                    ],
                  ),
                ],
              ),
            ],
          ),
        ],
      ),
    ],
  ),
)

assert parse(
  "{\"1\":{\"2\":{\"3\":{\"4\":{\"5\":{\"6\":{\"7\":{\"8\":{\"9\":{\"10\":{}}}}}}}}}}}",
) ==
Ok(
  JSONObject(
    [
      ("1", JSONObject(
        [
          ("2", JSONObject(
            [
              ("3", JSONObject(
                [
                  ("4", JSONObject(
                    [
                      ("5", JSONObject(
                        [
                          ("6", JSONObject(
                            [
                              ("7", JSONObject(
                                [
                                  ("8", JSONObject(
                                    [
                                      ("9", JSONObject(
                                        [("10", JSONObject([]))],
                                      )),
                                    ],
                                  )),
                                ],
                              )),
                            ],
                          )),
                        ],
                      )),
                    ],
                  )),
                ],
              )),
            ],
          )),
        ],
      )),
    ],
  ),
)

assert parse("[1,2,3]") ==
Ok(JSONArray([JSONNumber(1), JSONNumber(2), JSONNumber(3)]))
assert parse("[\"a\",\"b\",\"c\"]") ==
Ok(JSONArray([JSONString("a"), JSONString("b"), JSONString("c")]))

// White spaces
assert parse("\tnull \r\n") == Ok(JSONNull)
assert parse("  {\r}") == Ok(JSONObject([]))
assert parse("[1,\n2\n,3\n]\n") ==
Ok(JSONArray([JSONNumber(1), JSONNumber(2), JSONNumber(3)]))
assert parse("{ \"a\" :  \"A\" ,  \"b\" : \"B\" }") ==
Ok(JSONObject([("a", JSONString("A")), ("b", JSONString("B"))]))

// Invalid inputs

// JSON numbers should start with a non zero digit or minus sign.
assert match (parse("01")) {
  Err(UnexpectedToken(_)) => true,
  _ => false,
}

assert match (parse(".1")) {
  Err(UnexpectedToken(_)) => true,
  _ => false,
}

assert match (parse("{}error")) {
  Err(UnexpectedToken(_)) => true,
  _ => false,
}

assert match (parse("[]error")) {
  Err(UnexpectedToken(_)) => true,
  _ => false,
}

assert match (parse("]")) {
  Err(UnexpectedToken(_)) => true,
  _ => false,
}

assert match (parse("}")) {
  Err(UnexpectedToken(_)) => true,
  _ => false,
}

assert match (parse("{")) {
  Err(UnexpectedEndOfInput(_)) => true,
  _ => false,
}

assert match (parse("\"k\":\"v\"")) {
  Err(UnexpectedToken(_)) => true,
  _ => false,
}

assert match (parse("[")) {
  Err(UnexpectedEndOfInput(_)) => true,
  _ => false,
}

assert match (parse("{\"k")) {
  Err(UnexpectedEndOfInput(_)) => true,
  _ => false,
}

assert match (parse("{\"k\"")) {
  Err(UnexpectedEndOfInput(_)) => true,
  _ => false,
}

assert match (parse("{\"k\":")) {
  Err(UnexpectedEndOfInput(_)) => true,
  _ => false,
}

assert match (parse("{\"k\":\"v")) {
  Err(UnexpectedEndOfInput(_)) => true,
  _ => false,
}

assert match (parse("{\"k\":\"v\"")) {
  Err(UnexpectedEndOfInput(_)) => true,
  _ => false,
}

// Emitting

// Simple values of each type
assert toStringCompact(JSONNull) == Ok("null")
assert toStringCompact(JSONBoolean(true)) == Ok("true")
assert toStringCompact(JSONBoolean(false)) == Ok("false")
assert toStringCompact(JSONString("")) == Ok("\"\"")
assert toStringCompact(JSONNumber(0)) == Ok("0")
assert toStringCompact(JSONArray([])) == Ok("[]")
assert toStringCompact(JSONObject([])) == Ok("{}")

// Note that number tests are sensitive both to compiler's interpretation of
// the constants as different number tags (simple numbers, float32, float64)
// and internal details of JSON formatting. We definetely want them to fail
// when the latter changes. The former shouldn't be an issue assuming here
// constants with decimal point or exponentials are float64.
assert toStringCompact(JSONNumber(-10)) == Ok("-10")
assert toStringCompact(JSONNumber(-2)) == Ok("-2")
assert toStringCompact(JSONNumber(-1)) == Ok("-1")
assert toStringCompact(JSONNumber(1)) == Ok("1")
assert toStringCompact(JSONNumber(2)) == Ok("2")
assert toStringCompact(JSONNumber(10)) == Ok("10")
assert toStringCompact(JSONNumber(100)) == Ok("100")
assert toStringCompact(JSONNumber(1000)) == Ok("1000")
assert toStringCompact(JSONNumber(0.0)) == Ok("0.0")
assert toStringCompact(JSONNumber(0.1)) == Ok("0.1")
assert toStringCompact(JSONNumber(0.123)) == Ok("0.123")
assert toStringCompact(JSONNumber(0.9)) == Ok("0.9")
assert toStringCompact(JSONNumber(1.123)) == Ok("1.123")
assert toStringCompact(JSONNumber(0e0)) == Ok("0.0")
assert toStringCompact(JSONNumber(1e0)) == Ok("1.0")
assert toStringCompact(JSONNumber(1e1)) == Ok("10.0")
assert toStringCompact(JSONNumber(1E1)) == Ok("10.0")
assert toStringCompact(JSONNumber(1e2)) == Ok("100.0")
assert toStringCompact(JSONNumber(1e3)) == Ok("1000.0")
assert toStringCompact(JSONNumber(-1e2)) == Ok("-100.0")
assert toStringCompact(JSONNumber(1e-1)) == Ok("0.1")
assert toStringCompact(JSONNumber(1.23e-4)) == Ok("0.000123")

// FIXME semantics for negative zero still not defined

// Big numbers
assert toStringCompact(JSONNumber(1152921504606846976)) == Ok("1152921504606846976")
assert toStringCompact(JSONNumber(1152921504606847000.0)) == Ok("1152921504606847000.0")

// Invalid numbers

// There's currently a github issue for NaN and infinity syntax: https://github.com/grain-lang/grain/issues/693
let nan = 0.0 / 0.0
let infinity = 1.0 / 0.0
let negativeinfinity = -1.0 / 0.0

assert match (toStringCompact(JSONNumber(nan))) {
  Err(InvalidNumber(_)) => true,
  _ => false,
}

assert match (toStringCompact(JSONNumber(infinity))) {
  Err(InvalidNumber(_)) => true,
  _ => false,
}

assert match (toStringCompact(JSONNumber(negativeinfinity))) {
  Err(InvalidNumber(_)) => true,
  _ => false,
}

// TODO round trips

// TODO pretty printing
