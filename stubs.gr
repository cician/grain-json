/*
This file contains stubs for functions that I think need to be part of Grain's standard library.
*/

import WasmI32 from "runtime/unsafe/wasmi32"
import Int32 from "int32"
import Float64 from "float64"
import Conv from "runtime/unsafe/conv"
import WasmF64 from "runtime/unsafe/wasmf64"
import NumberUtils from "runtime/numberUtils"

@disableGC
export let int32ToHex = (i: Int32) => {
	let ptr = WasmI32.fromGrain(i)
	let int = WasmI32.load(ptr, 8n)
	let hex = NumberUtils.itoa32(int, 16n)
	hex
}

// This is taken from NumberUtils and adapted to work on Float64
// I'd add these to Float64 module and .
export let isFinite = (value: Float64) => {
	let wf64 = Conv.fromFloat64(value)
	WasmF64.eq(WasmF64.sub(wf64, wf64), 0.W)
}

export let isNaN = (value: Float64) => {
	let wf64 = Conv.fromFloat64(value)
  	WasmF64.ne(wf64, wf64)
}

export let unicodeCodepointToSurrogatePair = (codePoint: Number) => {
	// The content of this function is based on code from OpenJDK and thus subject to the GPL license (not LGPL).
	// So it may be for the better if someone else reimplemented it scratch.
	let _MIN_LOW_SURROGATE = 0xDC00
	let _MIN_HIGH_SURROGATE = 0xD800
	let _MIN_SUPPLEMENTARY_CODE_POINT = 0x010000

	let lowSurrogate = ((codePoint & 0x3ff) + _MIN_LOW_SURROGATE)
	let highSurrogate = ((codePoint >>> 10) + (_MIN_HIGH_SURROGATE - (_MIN_SUPPLEMENTARY_CODE_POINT >>> 10)))
	(lowSurrogate,highSurrogate)
}
