/*
This file contains stubs for functions that I think need to be part of Grain's standard library.
*/

import WasmI32 from "runtime/unsafe/wasmi32"
import Memory from "runtime/unsafe/memory"
import { tagSimpleNumber, allocateString } from "runtime/dataStructures"
import { coerceNumberToWasmI32 } from "runtime/numbers"
import String from "string"
import Exception from "runtime/exception"
import Tags from "runtime/unsafe/tags"
import Bytes from "bytes"

let _STRING_SIZE_OFFSET = 4n
let _STRING_VALUE_OFFSET = 8n
let _BYTES_SIZE_OFFSET = 4n;
let _BYTES_VALUE_OFFSET = 8n
let _CHAR_VALUE_OFFSET = 4n

@disableGC
let copyFromLinearMemoryToBytes = (srcPtr: WasmI32, srcPos: Number, dstPos: Number, len: Number, dst: Bytes) => {
	// based on Bytes.move

	let (+) = WasmI32.add
	let (>) = WasmI32.gtS

	let dstPtr = WasmI32.fromGrain(dst)

	let srcPosW = coerceNumberToWasmI32(srcPos)
	let dstPosW = coerceNumberToWasmI32(dstPos)
	let lenW = coerceNumberToWasmI32(len)

	let dstSizeW = WasmI32.load(dstPtr, _BYTES_SIZE_OFFSET) // or just getSize if in Bytes module
	if ((dstPosW + lenW) > dstSizeW) {
		throw InvalidArgument("Invalid destination bytes range")
	}

	Memory.copy(dstPtr + _BYTES_VALUE_OFFSET + dstPosW, srcPtr + srcPosW, lenW)
}

@disableGC
export let charUTF8SizeInBytes = (c: Char) => {
	// This is based on Char.toString()
	let (&) = WasmI32.and
	let (==) = WasmI32.eq

	let charPtr = WasmI32.fromGrain(c)
	let byte = WasmI32.load8U(charPtr, 4n)
	
	if ((byte & 0x80n) == 0x00n) {
		1
	} else if ((byte & 0xF0n) == 0xF0n) {
		4
	} else if ((byte & 0xE0n) == 0xE0n) {
		3
	} else {
		2
	}
}

@disableGC
export let numberOfBytesForUTF8CodePoint = (code: Number) => {
	// based on Char.code()

	let (<=) = WasmI32.leU
	let (==) = WasmI32.eq
	let (>>>) = WasmI32.shrU
	let (&) = WasmI32.and

	let code = WasmI32.fromGrain(code)
	if ((code & 1n) == 0n) {
		throw InvalidArgument("Invalid character code")
	}

	let code = code >>> 1n

	if (code <= 0x007Fn) {
		1
	} else if (code <= 0x07FFn) {
		2
	} else if (code <= 0xFFFFn) {
		3
	} else {
		4
	}
}

@disableGC
export let writeCharToBytesAsUTF8 = (dstPos: Number, c: Char, dst: Bytes) => {
	let srcPtr = WasmI32.add(WasmI32.fromGrain(c), _CHAR_VALUE_OFFSET)

	let size = charUTF8SizeInBytes(c)

	copyFromLinearMemoryToBytes(srcPtr, 0, dstPos, size, dst)

	// return the number of bytes written
	size
}

// This is copied verbatim from Bytes module. Only because not exposed.
/** Throws an exception if the index specified is out-of-bounds */
@disableGC
let checkIndexIsInBounds = (i, byteSize, max) => {
  let (+) = WasmI32.add
  let (<) = WasmI32.ltS
  let (>) = WasmI32.gtS
  if (i < 0n) {
    throw Exception.IndexOutOfBounds
  }
  if ((i + byteSize) > max) {
    throw Exception.IndexOutOfBounds
  }
}

@disableGC
export let writeUnicodeCodePointToBytesAsUTF8 = (dstPos: Number, code: Number, dst: Bytes) => {
	// Reference implementation:
	// writeCharToBytesAsUTF8(dstPos, Char.fromCode(code), dst) 

	// based on Char.fromCode()
	let (+) = WasmI32.add
	let (-) = WasmI32.sub
	let (*) = WasmI32.mul
	let (==) = WasmI32.eq
	let (>) = WasmI32.gtU
	let (<=) = WasmI32.leU
	let (<) = WasmI32.ltU
	let (>>>) = WasmI32.shrU
	let (&) = WasmI32.and
	let (|) = WasmI32.or

	let code = WasmI32.fromGrain(code)
	if ((code & 1n) == 0n) {
		throw InvalidArgument("Invalid character code")
	}

	let dstPtr = WasmI32.fromGrain(dst)
	let mut dstPosW = coerceNumberToWasmI32(dstPos)
	let mut dstPtrWithInitialOffset = dstPtr + _BYTES_VALUE_OFFSET + dstPosW

	//let bufSize = Bytes.length(dst)
	//let bufSizeW = coerceNumberToWasmI32(bufSize)
	let bufSizeW = WasmI32.load(dstPtr, _BYTES_SIZE_OFFSET) // or just getSize if in Bytes module

	let code = code >>> 1n
	
	if (code < 0x80n) {
		checkIndexIsInBounds(dstPosW, 1n, bufSizeW)
		WasmI32.store8(dstPtrWithInitialOffset, code, 0n)

		1
	} else {
		let mut numBytes = 0n
		let mut count = 0n
		let mut offset = 0n
		if (code <= 0x07FFn) {
			count = 1n
			offset = 0xC0n
			numBytes = 2n
		} else if (code <= 0xFFFFn) {
			count = 2n
			offset = 0xE0n
			numBytes = 3n
		} else {
			count = 3n
			offset = 0xF0n
			numBytes = 4n
		}
		
		checkIndexIsInBounds(dstPosW, numBytes, bufSizeW)

		WasmI32.store8(dstPtrWithInitialOffset, (code >>> (6n * count)) + offset, 0n)

		let mut n = 0n
		while (count > 0n) {
			n += 1n
			let temp = code >>> (6n * (count - 1n))
			WasmI32.store8(dstPtrWithInitialOffset + n, 0x80n | (temp & 0x3Fn), 0n)
			count -= 1n
		}

		tagSimpleNumber(numBytes)
	}
}

// this function is copied verbatim from String module in stdlib
exception MalformedUnicode

@disableGC
let getCodePoint = (ptr: WasmI32) => {
  // Algorithm from https://encoding.spec.whatwg.org/#utf-8-decoder
  let (+) = WasmI32.add
  let (==) = WasmI32.eq
  let (>=) = WasmI32.geU
  let (<=) = WasmI32.leU
  let (<<) = WasmI32.shl
  let (&) = WasmI32.and
  let (|) = WasmI32.or

  let mut codePoint = 0n
  let mut bytesSeen = 0n
  let mut bytesNeeded = 0n
  let mut lowerBoundary = 0x80n
  let mut upperBoundary = 0xBFn

  let mut offset = 0n

  let mut result = 0n

  while (true) {
    let byte = WasmI32.load8U(ptr + offset, 0n)
    offset += 1n
    if (bytesNeeded == 0n) {
      if (byte >= 0x00n && byte <= 0x7Fn) {
        result = byte
        break
      } else if (byte >= 0xC2n && byte <= 0xDFn) {
        bytesNeeded = 1n
        codePoint = byte & 0x1Fn
      } else if (byte >= 0xE0n && byte <= 0xEFn) {
        if (byte == 0xE0n) lowerBoundary = 0xA0n
        if (byte == 0xEDn) upperBoundary = 0x9Fn
        bytesNeeded = 2n
        codePoint = byte & 0xFn
      } else if (byte >= 0xF0n && byte <= 0xF4n) {
        if (byte == 0xF0n) lowerBoundary = 0x90n
        if (byte == 0xF4n) upperBoundary = 0x8Fn
        bytesNeeded = 3n
        codePoint = byte & 0x7n
      } else {
        throw MalformedUnicode
      }
      continue
    }
    if (!(lowerBoundary <= byte && byte <= upperBoundary)) {
      throw MalformedUnicode
    }
    lowerBoundary = 0x80n
    upperBoundary = 0xBFn
    codePoint = (codePoint << 6n) | (byte & 0x3Fn)
    bytesSeen += 1n
    if (bytesSeen == bytesNeeded) {
      result = codePoint
      break
    }
  }
  result: WasmI32
}

/**
 * Iterates over Unicode code points in this string.
 * 
 * @param f: (Number) -> Void - The iterator function
 * @param s: String - The string to iterate
 * @returns Void
 */
@disableGC
export let forEachCodePoint = (f: (Number) -> Void, s: String) => {
  let (>>>) = WasmI32.shrU
  let (-) = WasmI32.sub
  let (&) = WasmI32.and
  let (<) = WasmI32.ltU
  let (<=) = WasmI32.leU
  let (==) = WasmI32.eq
  let (+) = WasmI32.add

  let s = WasmI32.fromGrain(s)

  let byteSize = WasmI32.load(s, 4n)

  let mut ptr = s + 8n
  let end = ptr + byteSize
  
  let mut idx = 0n
  while (ptr < end) {
    let byte = WasmI32.load8U(ptr, 0n)
    let codePointByteCount = if ((byte & 0x80n) == 0x00n) {
      1n
    } else if ((byte & 0xF0n) == 0xF0n) {
      4n
    } else if ((byte & 0xE0n) == 0xE0n) {
      3n
    } else {
      2n
    }

    // Note that even if up to 4 bytes are needed to represent Unicode
    // codepoints, this doesn't mean 32 bits. The highest allowed code point is
    // 0x10FFFF and it should not change in future versions of Unicode. Which
    // means no more than 21 bits are necessary to represent a code point and
    // thus we can use Grain's "simple" numbers that hold up to 31 bits and
    // avoid heap allocations. I'm assuming here that getCodePoint would throw
    // MalformedUnicode exception for values exceeding this limit.
    let codePoint = getCodePoint(ptr)
    f(tagSimpleNumber(codePoint))

    ptr += codePointByteCount
    idx += 1n
  }
}
