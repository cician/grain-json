/*
This file contains stubs for functions that I think need to be part of Grain's standard library.
*/

import WasmI32 from "runtime/unsafe/wasmi32"
import Memory from "runtime/unsafe/memory"
import { tagSimpleNumber, allocateString } from "runtime/dataStructures"
import { coerceNumberToWasmI32 } from "runtime/numbers"
import String from "string"
import Exception from "runtime/exception"
import Tags from "runtime/unsafe/tags"
import Bytes from "bytes"

let _MIN_LOW_SURROGATE = 0xDC00
let _MIN_HIGH_SURROGATE = 0xD800

export let getUnicodeCodepointUTF16LowSurrogate = (codePoint: Number) => {
	// The content of this function is based on code from the .NET runtime
	// (MIT licensed).
	(codePoint & 0x3FF) + _MIN_LOW_SURROGATE
}


export let getUnicodeCodepointUTF16HighSurrogate = (codePoint: Number) => {
	// The content of this function is based on code from the .NET runtime
	// (MIT licensed).
	(codePoint + ((_MIN_HIGH_SURROGATE - 0x40) << 10)) >> 10
}

export let unicodeCodepointToUTF16SurrogatePair = (codePoint: Number) => {
	(getUnicodeCodepointUTF16LowSurrogate(codePoint), getUnicodeCodepointUTF16HighSurrogate(codePoint))
}

let _STRING_SIZE_OFFSET = 4n
let _STRING_VALUE_OFFSET = 8n
let _BYTES_SIZE_OFFSET = 4n;
let _BYTES_VALUE_OFFSET = 8n
let _CHAR_VALUE_OFFSET = 4n

@disableGC
export let copyFromLinearMemoryToBytes = (srcPtr: WasmI32, srcPos: Number, dstPos: Number, len: Number, dst: Bytes) => {
	// based on Bytes.move

	let (+) = WasmI32.add
	let (>) = WasmI32.gtS

	let dstPtr = WasmI32.fromGrain(dst)

	let srcPosW = coerceNumberToWasmI32(srcPos)
	let dstPosW = coerceNumberToWasmI32(dstPos)
	let lenW = coerceNumberToWasmI32(len)

	let dstSizeW = WasmI32.load(dstPtr, _BYTES_SIZE_OFFSET) // or just getSize if in Bytes module
	if ((dstPosW + lenW) > dstSizeW) {
		throw InvalidArgument("Invalid destination bytes range")
	}

	Memory.copy(dstPtr + _BYTES_VALUE_OFFSET + dstPosW, srcPtr + srcPosW, lenW)
}

@disableGC
export let writeStringToBytesAsUTF8 = (dstPos: Number, str: String, dst: Bytes) => {
	// This function could be replaced in the future if this gets adjusted with my suggestion and merged:
	// https://github.com/grain-lang/grain/pull/683

	let srcPtr = WasmI32.add(WasmI32.fromGrain(str), _STRING_VALUE_OFFSET)

	// like String.byteLength, but without wrapping to Number
	let size = String.byteLength(str)

	copyFromLinearMemoryToBytes(srcPtr, 0, dstPos, size, dst)

	// return the number of bytes written
	size
}

@disableGC
export let charUTF8SizeInBytes = (c: Char) => {
	// This is based on Char.toString()
	let (&) = WasmI32.and
	let (==) = WasmI32.eq

	let charPtr = WasmI32.fromGrain(c)
	let byte = WasmI32.load8U(charPtr, 4n)
	
	if ((byte & 0x80n) == 0x00n) {
		1
	} else if ((byte & 0xF0n) == 0xF0n) {
		4
	} else if ((byte & 0xE0n) == 0xE0n) {
		3
	} else {
		2
	}
}

@disableGC
export let numberOfBytesForUTF8CodePoint = (code: Number) => {
	// based on Char.code()

	let (<=) = WasmI32.leU
	let (==) = WasmI32.eq
	let (>>>) = WasmI32.shrU
	let (&) = WasmI32.and

	let code = WasmI32.fromGrain(code)
	if ((code & 1n) == 0n) {
		throw InvalidArgument("Invalid character code")
	}

	let code = code >>> 1n

	if (code <= 0x007Fn) {
		1
	} else if (code <= 0x07FFn) {
		2
	} else if (code <= 0xFFFFn) {
		3
	} else {
		4
	}
}

@disableGC
export let writeCharToBytesAsUTF8 = (dstPos: Number, c: Char, dst: Bytes) => {
	let srcPtr = WasmI32.add(WasmI32.fromGrain(c), _CHAR_VALUE_OFFSET)

	let size = charUTF8SizeInBytes(c)

	copyFromLinearMemoryToBytes(srcPtr, 0, dstPos, size, dst)

	// return the number of bytes written
	size
}

// This is copied verbatim from Bytes module. Only because not exposed.
/** Throws an exception if the index specified is out-of-bounds */
@disableGC
let checkIndexIsInBounds = (i, byteSize, max) => {
  let (+) = WasmI32.add
  let (<) = WasmI32.ltS
  let (>) = WasmI32.gtS
  if (i < 0n) {
    throw Exception.IndexOutOfBounds
  }
  if ((i + byteSize) > max) {
    throw Exception.IndexOutOfBounds
  }
}

@disableGC
export let writeUnicodeCodePointToBytesAsUTF8 = (dstPos: Number, code: Number, dst: Bytes) => {
	// Reference implementation:
	// writeCharToBytesAsUTF8(dstPos, Char.fromCode(code), dst) 

	// based on Char.fromCode()
	let (+) = WasmI32.add
	let (-) = WasmI32.sub
	let (*) = WasmI32.mul
	let (==) = WasmI32.eq
	let (>) = WasmI32.gtU
	let (<=) = WasmI32.leU
	let (<) = WasmI32.ltU
	let (>>>) = WasmI32.shrU
	let (&) = WasmI32.and
	let (|) = WasmI32.or

	let code = WasmI32.fromGrain(code)
	if ((code & 1n) == 0n) {
		throw InvalidArgument("Invalid character code")
	}

	let dstPtr = WasmI32.fromGrain(dst)
	let mut dstPosW = coerceNumberToWasmI32(dstPos)
	let mut dstPtrWithInitialOffset = dstPtr + _BYTES_VALUE_OFFSET + dstPosW

	//let bufSize = Bytes.length(dst)
	//let bufSizeW = coerceNumberToWasmI32(bufSize)
	let bufSizeW = WasmI32.load(dstPtr, _BYTES_SIZE_OFFSET) // or just getSize if in Bytes module

	let code = code >>> 1n
	
	if (code < 0x80n) {
		checkIndexIsInBounds(dstPosW, 1n, bufSizeW)
		WasmI32.store8(dstPtrWithInitialOffset, code, 0n)

		1
	} else {
		let mut numBytes = 0n
		let mut count = 0n
		let mut offset = 0n
		if (code <= 0x07FFn) {
			count = 1n
			offset = 0xC0n
			numBytes = 2n
		} else if (code <= 0xFFFFn) {
			count = 2n
			offset = 0xE0n
			numBytes = 3n
		} else {
			count = 3n
			offset = 0xF0n
			numBytes = 4n
		}
		
		checkIndexIsInBounds(dstPosW, numBytes, bufSizeW)

		WasmI32.store8(dstPtrWithInitialOffset, (code >>> (6n * count)) + offset, 0n)

		let mut n = 0n
		while (count > 0n) {
			n += 1n
			let temp = code >>> (6n * (count - 1n))
			WasmI32.store8(dstPtrWithInitialOffset + n, 0x80n | (temp & 0x3Fn), 0n)
			count -= 1n
		}

		tagSimpleNumber(numBytes)
	}
}
