import String from "string"
import Char from "char"
import Array from "array"
import StringBuilder from "stringbuilder"
import Option from "option"
import Number from "number"
import Stubs from "stubs"

export enum JSON {
	JSONNull,
	JSONBoolean(Bool),
	JSONNumber(Number),
	JSONString(String),
	// Here I've chosen to use a List and not an array as a conscious trad of performance for immutability.
	// I'd love to use a more advanced persistent collection instead, but there currently aren't any in Grain.
	JSONArray(List<JSON>),
	// Note that JSONObject here is deliberately defined as a simple list of key value pair tuples as opposed
	// to for example a Map in order to accomodate the fact that the ECMA-404 standard doesn't prohibit
	// duplicate names in Objects. Such JSON should be representable by the JSON data structure for lossless
	// processing. This also vastly simplifies implementation and has the benefit of List's immutability.
	JSONObject(List<(String,JSON)>)
}

export exception InvalidJSON(String)

export enum IndentationFormat {
	NoIndentation,
	IndentWithTab,
	IndentWithSpaces(Number)
}

export enum ArrayFormat {
	CompactArrayEntries,
	OneArrayEntryPerLine
}

export enum ObjectFormat {
	CompactObjectEntries,
	OneObjectEntryPerLine
}

export enum LineEnding {
	NoLineEnding,
	LineFeed,
	CarriageReturnLineFeed,
	CarriageReturn
}

export record FormattingSettings {
	indentation: IndentationFormat,
	arrayFormat: ArrayFormat,
	objectFormat: ObjectFormat,
	lineEnding: LineEnding,
	finishWithNewLine: Bool,
	escapeAllControlPoints: Bool,
	escapeHTMLUnsafeSequences: Bool,
	escapeNonASCII: Bool
}

// Compact formatting that minimizes the size of resulting JSON at cost of not being easily human readable.
// Only performs minimal string escaping as required by the ECMA-404 standard, so the result needs to
// be treated as proper unicode and is not safe to be transported in ASCII encoding.
export let defaultCompactFormat =
	() => {
		indentation: NoIndentation,
		arrayFormat: CompactArrayEntries,
		objectFormat: CompactObjectEntries,
		lineEnding: NoLineEnding,
		finishWithNewLine: false,
		escapeAllControlPoints: false,
		escapeHTMLUnsafeSequences: false,
		escapeNonASCII: false
	} : FormattingSettings

// Recommended human readable formatting.
// Escapes all control points for the sake of clarity, but doesn't go the extra mile to escape additional
// sequences or unicode characters.
export let defaultPrettyFormat =
	() => {
		indentation: IndentWithSpaces(2),
		arrayFormat: OneArrayEntryPerLine,
		objectFormat: OneObjectEntryPerLine,
		lineEnding: LineFeed,
		finishWithNewLine: true,
		escapeAllControlPoints: true,
		escapeHTMLUnsafeSequences: false,
		escapeNonASCII: false
	} : FormattingSettings

// Compact and conservative formatting to maximize compatibility and embeddability of the resulting JSON.
// Should be safe to copy and paste directly into HTML and to transported in plain ASCII.
export let defaultCompactAndSafeFormat =
	() => {
		indentation: NoIndentation,
		arrayFormat: CompactArrayEntries,
		objectFormat: CompactObjectEntries,
		lineEnding: NoLineEnding,
		finishWithNewLine: false,
		escapeAllControlPoints: true,
		escapeHTMLUnsafeSequences: true,
		escapeNonASCII: true
	} : FormattingSettings

// Pretty and conservative formatting to maximize compatibility and embeddability of the resulting JSON.
// Should be safe to copy and paste directly into HTML and to transported in plain ASCII.
export let defaultPrettyAndSafeFormat =
	() => {
		indentation: IndentWithSpaces(2),
		arrayFormat: OneArrayEntryPerLine,
		objectFormat: OneObjectEntryPerLine,
		lineEnding: LineFeed,
		finishWithNewLine: true,
		escapeAllControlPoints: true,
		escapeHTMLUnsafeSequences: true,
		escapeNonASCII: true
	} : FormattingSettings

// Abstract target for printing text.
// If the decision is made to never do anything other than emitting
// to a String then it should be removed for slightly better efficiency and less complexity.
// For now it's useful to me to measure performance separately from the cost of printing.
record Printer {
	write: String -> Void,
	writeChar: Char -> Void,
	writeUnicodeCodePoint: Number -> Void,
}

record JSONWriterCompactImplHelper {
	printer: Printer,
	emitEscapedQuotedString: String -> Void,
}

record JSONWriterPrettyImplHelper {
	format: FormattingSettings,
	// Note that the "Pretty" suffix here is a workaround for a Grain compiler bug.
	// It generates warnings just because two record types have some field names in common.
	// Unless there's something I don't understand about its type system.
	printerPretty: Printer,
	emitEscapedQuotedStringPretty: String -> Void,
	printNewLine: () -> Void,
	printIndentation: Number -> Void,
}

// The idea for this type is to allow reusing a bit of work done in preparing for printing JSON.
// For now this is not exposed and remains an internal implementation detail.
// It may make sense in the future to expose it and let the user reuse a writer for multiple
// JSON emit operations without reallocating new closures and buffers each time.
record JSONWriter {
	emit: JSON -> Option<Exception>,
}

let makeStringBuilderPrinter = (buf: StringBuilder.StringBuilder) => {
	{
		write: s => StringBuilder.append(s, buf),
		writeChar: c => StringBuilder.appendChar(c, buf),
		writeUnicodeCodePoint: (c) => {
			StringBuilder.appendUnicodeCodePoint(c, buf)
		}
	} : Printer
}

let makeDummyPrinter = () => {
	{
		write: s => void,
		writeChar: c => void,
		writeUnicodeCodePoint: c => void,
	} : Printer
}

let emitUTF16EscapeSequence = (codePoint: Number, printer: Printer) => {
	// Emit the "\u" followed by hexadecimal representation of the codepoint
	// with fixed length of 4 hexadecimal digits correspondeing to the two byte
	// codepoint. No checks are performed here if the codepoint is in the
	// "Basic Multilingual Plane" (0000-FFFF) as this funcion is only called
	// internally.
	// An alternative was to this implementation was to use NumberUtils.itoa32,
	// but I wanted to avoid unnecessary heap allocations. As a possible future
	// optimization this loop could be unrolled possibly even converted to be
	// branchless and SIMD optimized, but it could be a bit of an overkill as
	// this codepath is only for escape sequences, which probably aren't all
	// that common occurence.

	//printer.write("\\u");
	printer.writeUnicodeCodePoint(92)
	printer.writeUnicodeCodePoint(117)
	// Loop over the four digit from most to least significant.
	for (let mut digitIndex=3; digitIndex>=0; digitIndex -= 1) {
		// Use bit masking and shifting to extract from the codepoint a number
		// with just the bits corresponding to this hexadecinak digit.
		let shift = digitIndex * 4
		let mask = 0b1111 << shift
		let digit = (codePoint & mask) >>> shift

		// Digit now is a number in the range 0..15 and we need to translate it
		// into a unicode codepoint representing the hexacedimal digit
		// (0..9/a..f). We can use the fact that digits and latin letters in
		// ASCII and by extension in Unicode are adjacent and ordered.
		let hexDigitCodePoint =
			if (digit <= 9) {
				// 48 is codeppoint for char '0'
				digit + 48
			} else {
				// 97 is codeppoint for char 'a'
				// But we also need to subtract 10 from it because we need
				// the 10..15 number range translated to 0..5 in order to
				// serve as an index in the ASCI range 'a'..'f'.
				digit + 87
			}

		printer.writeUnicodeCodePoint(hexDigitCodePoint)
	}
}

let emitEscapedUnicodeSequence = (codePoint: Number, printer: Printer) => {
	// See the String section in the ECMA-404 doc.
	// If the code point is "in the Basic Multilingual Plane", that is in range
	// 0..65535. Greater values need to be split into two UTF-16 chunks.
	if (codePoint <= 0xFFFF) {
		// emitUTF16EscapeSequence(codePoint, writer)
		emitUTF16EscapeSequence(codePoint, printer)
	} else {
		// The following three lines are copied from String module of Grain's
		// stdlib. It would be nice to share more code. On the other hand it
		// may make sense to juste have these few instructions directly here
		// from the performance standpoint so we can print millions of emojis
		// per second ðŸ˜„.

		// https://en.wikipedia.org/wiki/UTF-16#Code_points_from_U+010000_to_U+10FFFF
		let uPrime = codePoint - 0x10000
		let highSurrogate = ((uPrime & 0b11111111110000000000) >>> 10) + 0xD800 // High surrogate
		let lowSurrogate = (uPrime & 0b00000000001111111111) + 0xDC00 // Low surrogate

		// emitUTF16EscapeSequence(highSurrogate, writer)
		emitUTF16EscapeSequence(highSurrogate, printer)
		// emitUTF16EscapeSequence(lowSurrogate, writer)
		emitUTF16EscapeSequence(lowSurrogate, printer)
	}
}

let emitEscapedCodePoint = (codePoint: Number, printer: Printer) => {
	match (codePoint) {
		0x0008 => { // backspace
			//printer.write("\\b")
			printer.writeUnicodeCodePoint(0x5C)
			printer.writeUnicodeCodePoint(0x62)
		},
		0x0009 => { // tab
			//printer.write("\\t")
			printer.writeUnicodeCodePoint(0x5C)
			printer.writeUnicodeCodePoint(0x74)
		},
		0x000A => { // line feed
			//printer.write("\\n")
			printer.writeUnicodeCodePoint(0x5C)
			printer.writeUnicodeCodePoint(0x6E)
		},
		0x000C => { // form feed
			//printer.write("\\f")
			printer.writeUnicodeCodePoint(0x5C)
			printer.writeUnicodeCodePoint(0x66)
		},
		0x000D => { // carriage return
			//printer.write("\\r")
			printer.writeUnicodeCodePoint(0x5C)
			printer.writeUnicodeCodePoint(0x72)
		},
		0x0022 => { // quotation mark
			//printer.write("\\\"")
			printer.writeUnicodeCodePoint(0x5C)
			printer.writeUnicodeCodePoint(0x22)
		},
		0x005C => { // backslash or "Reverse Solidus"
			//printer.write("\\\\")
			printer.writeUnicodeCodePoint(0x5C)
			printer.writeUnicodeCodePoint(0x5C)
		},
		_ => {
			emitEscapedUnicodeSequence(codePoint, printer)
		}
	}
}

let printNull = (printer: Printer) => printer.write("null")

let printBool = (b: Bool, printer: Printer) => {
	if (b) {
		printer.write("true")
	} else {
		printer.write("false")
	}
}

let printNumber = (n: Number, printer: Printer) => {
	if (Number.isFinite(n)) {
		// In order to not duplicate code here I simply use Grain's
		// toString of Number. This is a bit risky because as far as I
		// can tell what it outputs is not formally documented. So
		// any changes to that could result in invalid JSON here. For
		// now at least it was considered the way to go. If one day a
		// decision is made to fork that function. The starting point
		// would be NumberUtils.dtoa and some optimizations could
		// probably be done like avoiding memory allocations or
		// checking for NaNs/Infs two times.
		// FIXME normalize rational numbers
		printer.write(toString(n))
		None
	} else {
		// JSON standard doesn't allow NaN or infinite values in numbers,
		// but WASM f64 (IEEE 754-2008), as well as Grain's number types do
		// (Float64 as well as Number). This is the only reason that the
		// formatting needs to return a Result and not just a String
		// directly. Other possible choices were to throw exceptions or to
		// coninue formatting without representing these values correctly
		// (like JavaScript's JSON.stringify).
		if (Number.isNaN(n)) {
			Some(InvalidJSON("NaN is not allowed in JSONNumber"))
		} else if (n < 0) {
			Some(InvalidJSON("-Infinity is not allowed in JSONNumber"))
		} else {
			Some(InvalidJSON("Infinity is not allowed in JSONNumber"))
		}
	}
}

// Note that this function is not allocated with the JSONWriter because currently
// Grain leaks memory each time a recursive closure is allocated. Not reallocating
// it may also be a better thing to do.
let rec printElementCompact = (json: JSON, implHelper: JSONWriterCompactImplHelper) => {
	let printer = implHelper.printer
	match (json) {
		JSONNull => {
			printNull(printer)
			None
		},
		JSONBoolean(b) => {
			printBool(b, printer)
			None
		},
		JSONNumber(n) => printNumber(n, printer),
		JSONString(s) => {
			implHelper.emitEscapedQuotedString(s)
			None
		},
		JSONArray(elems) => {
			// Here I'm not using List.forEachi or similar in order to avoid
			// allocations of closures. The code is verbose and a bit ugly as a
			// consequence, but I think it's an OK price for performance gain.
			// Another approach would be to allocate a function for the
			// formattng arrays just once at the start of formatting and pass
			// it in emitJSONElement.
			match (elems) {
				[] => {
					//printer.write("[]")
					printer.writeUnicodeCodePoint(0x5B)
					printer.writeUnicodeCodePoint(0x5D)
					None
				},
				[e] => {
					//printer.write("[")
					printer.writeUnicodeCodePoint(0x5B)
				
					let err = printElementCompact(e, implHelper)

					if (Option.isNone(err)) {
						//printer.write("]")
						printer.writeUnicodeCodePoint(0x5D)
					}

					err
				},
				[initialHead, ...initialRest] => {
					// printer.write("[")
					printer.writeUnicodeCodePoint(0x5B)

					let mut currentHead = initialHead
					let mut currentRest = initialRest

					let mut err = None

					for (let mut index = 0; ; index += 1) {
						if (index > 0) {
							// printer.write(",")
							printer.writeUnicodeCodePoint(0x2C)
						}

						err = printElementCompact(currentHead, implHelper)
						if (Option.isSome(err))
							break

						match (currentRest) {
							[] => break,
							[newHead, ...newRest] => {
								currentHead = newHead
								currentRest = newRest
							}
						}
					}

					if (Option.isNone(err)) {
						// printer.write("]")
						printer.writeUnicodeCodePoint(0x5D)
					}

					err
				}
			}
		},
		JSONObject(entries) => {
			match (entries) {
				[] => {
					// printer.write("{}")
					printer.writeUnicodeCodePoint(0x7B)
					printer.writeUnicodeCodePoint(0x7D)
					None
				},
				[(key, value)] => {
					//printer.writeChar('{')
					printer.writeUnicodeCodePoint(0x7B)
					
					implHelper.emitEscapedQuotedString(key)

					//printer.writeChar(':')
					printer.writeUnicodeCodePoint(0x3A)

					let err = printElementCompact(value, implHelper)

					if (Option.isNone(err)) {
						// printer.writeChar('}')
						printer.writeUnicodeCodePoint(0x7D)
					}
					
					err
				},
				[initialHead, ...initialRest] => {
					// printer.writeChar('{')
					printer.writeUnicodeCodePoint(0x7B)

					let mut currentHead = initialHead
					let mut currentRest = initialRest

					let mut err = None

					for (let mut index = 0; ; index += 1) {
						if (index > 0) {
							// printer.write(",")
							printer.writeUnicodeCodePoint(0x2C)
						}

						let (key, value) = currentHead
						
						implHelper.emitEscapedQuotedString(key)

						//printer.writeChar(':')
						printer.writeUnicodeCodePoint(0x3A)
						
						err = printElementCompact(value, implHelper)

						if (Option.isSome(err))
							break

						match (currentRest) {
							[] => break,
							[newHead, ...newRest] => {
								currentHead = newHead
								currentRest = newRest
							}
						}
					}

					if (Option.isNone(err)) {
						// printer.writeChar('}')
						printer.writeUnicodeCodePoint(0x7D)
					}

					err
				}
			}
		}
	}
}

let makeCompactJSONWriter = (printer: Printer) => {
	// As an optimization prepare a closure function to execute for each code
	// point of the input. It's important that this is not inlide in the
	// emitEscapedQuotedString function directly to avoid allocating the closue
	// for each input string.
	let emitCodePoint = (codePoint: Number) => {
		// For the compact formatting only escape code points 0..31 as required
		// by ECMA-404 (the so called "C0" control point group). For the non
		// pretty printed case we don't want to escape more than what is
		// stricty required to avoid increasing the output size.
		if (codePoint > 31) {
			printer.writeUnicodeCodePoint(codePoint)
		} else {
			emitEscapedCodePoint(codePoint, printer)
		}
	}
	
	let emitEscapedQuotedString = (s: String) => {
		//printer.write("\"")
		printer.writeUnicodeCodePoint(0x22)

		// If/when my PR gets merget hopefully this will be String.forEachCodePoint without need for intermediate allocations.
		Stubs.forEachCodePoint(emitCodePoint, s)

		//printer.write("\"")
		printer.writeUnicodeCodePoint(0x22)
	}

	let implHelper = {
		printer: printer,
		emitEscapedQuotedString: (s) => {
			emitEscapedQuotedString(s)
		},
	} : JSONWriterCompactImplHelper

	{
		emit: (json) => {
			let error = printElementCompact(json, implHelper)

			error
		},
	} : JSONWriter
}

// Note that this could relatively easily be integrated with
// printElementCompact to avoid code duplication, but it would mean
// compromising peak performance and also increasing complexity in other ways.
let rec printElementPretty = (json: JSON, implHelper: JSONWriterPrettyImplHelper, indentationLevel: Number) => {
	let printer = implHelper.printerPretty
	match (json) {
		JSONNull => {
			printNull(printer)
			None
		},
		JSONBoolean(b) => {
			printBool(b, printer)
			None
		},
		JSONNumber(n) => printNumber(n, printer),
		JSONString(s) => {
			implHelper.emitEscapedQuotedStringPretty(s)
			None
		},
		JSONArray(elems) => {
			match (elems) {
				[] => {
					//printer.write("[]")
					printer.writeUnicodeCodePoint(0x5B)
					printer.writeUnicodeCodePoint(0x5D)
					None
				},
				[e] => {
					let format = implHelper.format

					//printer.write("[")
					printer.writeUnicodeCodePoint(0x5B)

					if (format.arrayFormat == OneArrayEntryPerLine)
						implHelper.printNewLine()

					let elemLevel = indentationLevel+1
				
					if (format.arrayFormat == OneArrayEntryPerLine)
						implHelper.printIndentation(elemLevel)
				
					let err = printElementPretty(e, implHelper, elemLevel)

					if (Option.isNone(err)) {
						if (format.arrayFormat == OneArrayEntryPerLine) {
							implHelper.printNewLine()
							implHelper.printIndentation(indentationLevel)
						}
						
						//printer.write("]")
						printer.writeUnicodeCodePoint(0x5D)
					}

					err
				},
				[initialHead, ...initialRest] => {
					let format = implHelper.format

					// printer.write("[")
					printer.writeUnicodeCodePoint(0x5B)

					if (format.arrayFormat == OneArrayEntryPerLine)
						implHelper.printNewLine()

					let mut currentHead = initialHead
					let mut currentRest = initialRest

					let mut err = None

					let elemLevel = indentationLevel+1

					for (let mut index = 0; ; index += 1) {
						if (index > 0) {
							// printer.write(",")
							printer.writeUnicodeCodePoint(0x2C)

							if (format.arrayFormat == OneArrayEntryPerLine)
								implHelper.printNewLine()
						}

						if (format.arrayFormat == OneArrayEntryPerLine)
							implHelper.printIndentation(elemLevel)

						err = printElementPretty(currentHead, implHelper, elemLevel)
						if (Option.isSome(err))
							break

						match (currentRest) {
							[] => break,
							[newHead, ...newRest] => {
								currentHead = newHead
								currentRest = newRest
							}
						}
					}

					if (Option.isNone(err)) {
						if (format.arrayFormat == OneArrayEntryPerLine) {
							implHelper.printNewLine()
							implHelper.printIndentation(indentationLevel)
						}
						
						// printer.write("]")
						printer.writeUnicodeCodePoint(0x5D)
					}

					err
				}
			}
		},
		JSONObject(entries) => {
			match (entries) {
				[] => {
					// printer.write("{}")
					printer.writeUnicodeCodePoint(0x7B)
					printer.writeUnicodeCodePoint(0x7D)
					None
				},
				[(key, value)] => {
					let format = implHelper.format

					//printer.writeChar('{')
					printer.writeUnicodeCodePoint(0x7B)

					let elemLevel = indentationLevel+1

					if (format.objectFormat == OneObjectEntryPerLine) {
						implHelper.printNewLine()
						implHelper.printIndentation(elemLevel)
					}
					
					implHelper.emitEscapedQuotedStringPretty(key)

					match (format.objectFormat) {
						CompactObjectEntries => {
							//printer.writeChar(':')
							printer.writeUnicodeCodePoint(0x3A)
						},
						OneObjectEntryPerLine => {
							//printer.writeChar(':')
							printer.writeUnicodeCodePoint(0x3A)
							printer.writeUnicodeCodePoint(0x20)
						}
					}

					let err = printElementPretty(value, implHelper, elemLevel)

					if (Option.isNone(err)) {
						if (format.objectFormat == OneObjectEntryPerLine) {
							implHelper.printNewLine()
							implHelper.printIndentation(indentationLevel)
						}
						
						// printer.writeChar('}')
						printer.writeUnicodeCodePoint(0x7D)
					}
					
					err
				},
				[initialHead, ...initialRest] => {
					let format = implHelper.format

					// printer.writeChar('{')
					printer.writeUnicodeCodePoint(0x7B)

					if (format.objectFormat == OneObjectEntryPerLine)
						implHelper.printNewLine()

					let mut currentHead = initialHead
					let mut currentRest = initialRest

					let mut err = None

					let elemLevel = indentationLevel+1

					for (let mut index = 0; ; index += 1) {
						if (index > 0) {
							// printer.write(",")
							printer.writeUnicodeCodePoint(0x2C)

							if (format.objectFormat == OneObjectEntryPerLine)
								implHelper.printNewLine()
						}

						if (format.objectFormat == OneObjectEntryPerLine)
							implHelper.printIndentation(elemLevel)

						let (key, value) = currentHead
						
						implHelper.emitEscapedQuotedStringPretty(key)

						match (format.objectFormat) {
							CompactObjectEntries => {
								//printer.writeChar(':')
								printer.writeUnicodeCodePoint(0x3A)
							},
							OneObjectEntryPerLine => {
								//printer.write(": ")
								printer.writeUnicodeCodePoint(0x3A)
								printer.writeUnicodeCodePoint(0x20)
							}
						}
						
						err = printElementPretty(value, implHelper, elemLevel)

						if (Option.isSome(err))
							break

						match (currentRest) {
							[] => break,
							[newHead, ...newRest] => {
								currentHead = newHead
								currentRest = newRest
							}
						}
					}

					if (Option.isNone(err)) {
						if (format.objectFormat == OneObjectEntryPerLine) {
							implHelper.printNewLine()
							implHelper.printIndentation(indentationLevel)
						}
						
						// printer.writeChar('}')
						printer.writeUnicodeCodePoint(0x7D)
					}

					err
				}
			}
		}
	}
}

let makePrettyPrintJSONWriter = (format: FormattingSettings, printer: Printer) => {
	let printNewLine = match (format.lineEnding) {
		NoLineEnding => () => void,
		LineFeed => () => {
			//printer.writeChar('\n')
			printer.writeUnicodeCodePoint(0x0A)
		},
		CarriageReturnLineFeed => () => {
			//printer.write("\r\n")
			printer.writeUnicodeCodePoint(0x0D)
			printer.writeUnicodeCodePoint(0x0A)
		},
		CarriageReturn => () => {
			//printer.writeChar('\r')
			printer.writeUnicodeCodePoint(0x0D)
		},
	}
	
	let printIndentation = match (format.indentation) {
		IndentWithTab => (indentationLevel) => {
			let mut count = 0
			while (count < indentationLevel) {
				//printer.writeChar('\t')
				printer.writeUnicodeCodePoint(0x09)
				count += 1;
			}
		},
		IndentWithSpaces(spacesPerIndentation) => (indentationLevel) => {
			let mut count = 0
			let spaceCount = indentationLevel*spacesPerIndentation
			while (count < spaceCount) {
				//printer.writeChar(' ')
				printer.writeUnicodeCodePoint(0x20)
				count += 1;
			}
		},
		NoIndentation => (indentationLevel) => void
	}

	// FIXME the if expressions below leak memory (https://github.com/grain-lang/grain/issues/774)

	// As an optimization prepare a different closure function for each
	// combination of escaping options. This ways we can avoid unnecessary
	// branching in the code executed for each character. What is most
	// important here is to optimize for the non pretty printed format as this
	// is where the performance is most likely to matter. In every case escape
	// code points 0..31 as required by ECMA-404 (the so called "C0" control
	// point group). For the non pretty printed case we don't want to escape
	// more than what is stricty required to avoid increasing the output size.
	// But for pretty printing or compatiblity it may be desirable to escape
	// other control points or even everything other than printable ASCII
	// characters. Thus I've decided to expose options for this, but otherwise
	// just a sane default would suffice.
	// Additionally many JSON libraries escape additional two character
	// sequences for direct embedding into html for example. This is
	// specifically to avoid emitting the sequence "</" like in "</script>".
	// The lazy approach would be to just escape the slash (which can become
	// "\\/", not necessarily "\u002F"). This more conservative approach only
	// escapes it when needed, but requires to keep track of the previous code
	// point in the iteration so it's more complicated and handled separately.
	let emitCodePoint =
		if (!format.escapeAllControlPoints && !format.escapeNonASCII) {
			(codePoint: Number) => {
				if (codePoint > 31) {
					printer.writeUnicodeCodePoint(codePoint)
				} else {
					emitEscapedCodePoint(codePoint, printer)
				}
			}
		} else if (!format.escapeAllControlPoints && format.escapeNonASCII) {
			// If desired, escape all non ASCII code points. So the only non
			// escaped code points are those in the range of ASCII chacarcters
			// from 31 to 127.
			(codePoint: Number) => {
				if (codePoint > 31 && codePoint < 128 ) {
					printer.writeUnicodeCodePoint(codePoint)
				} else {
					emitEscapedCodePoint(codePoint, printer)
				}
			}
		} else if (format.escapeAllControlPoints && !format.escapeNonASCII) {
			// If desired, in addition to the required 0..31 control points,
			// also escape unicode control point group C1 (128-159).
			// There could be more control points or otherwise escape worthy
			// codepoints, but covering that would be overkill.
			(codePoint: Number) => {
				if ((codePoint > 31 && codePoint < 127) || codePoint > 159) {
					printer.writeUnicodeCodePoint(codePoint)
				} else {
					emitEscapedCodePoint(codePoint, printer)
				}
			}
		} else {
			// And this is just the combination of both flags, which means
			// doing almost the same as for the case above for
			// escapeNonASCII=true, but also escape the ASCII control codepoint
			// 127 (Delete).
			(codePoint: Number) => {
				if (codePoint > 31 && codePoint < 127) {
					// fast path for chars that never need any escaping
					printer.writeUnicodeCodePoint(codePoint)
				} else {
					emitEscapedCodePoint(codePoint, printer)
				}
			}
		}
	
	let emitEscapedQuotedString =
		if (!format.escapeHTMLUnsafeSequences) {
			(s: String) => {
				//printer.write("\"")
				printer.writeUnicodeCodePoint(0x22)

				// Note that it's important for performance that the closure passed to forEachCodePoint
				// is not allocated inline here, but just once when creating the writer.
				
				// If/when my PR gets merget hopefully this will be String.forEachCodePoint without need for intermediate allocations.
				Stubs.forEachCodePoint(emitCodePoint, s)

				//printer.write("\"")
				printer.writeUnicodeCodePoint(0x22)
			}
		} else {
			// Special handling for the escapeHTMLUnsafeSequences flag.
			// Escaping a sequence requires keeping track of previous characters,
			// which is difficult and suboptimal when using a function to iterate
			// the input string. So we don't want to pay the price in other cases.
			// This cannot be done just in the emitCodePoint function.
			// It could be possible to implement more optimally, but would
			// complicate things even more than this.
			(s: String) => {
				printer.writeUnicodeCodePoint(0x22)

				let mut prevCodePoint = 0

				Stubs.forEachCodePoint((codePoint) => {
					if (codePoint == 47) {
						if (format.escapeHTMLUnsafeSequences && prevCodePoint == 60) {
							//printer.write("\\/")
							printer.writeUnicodeCodePoint(92)
							printer.writeUnicodeCodePoint(47)
						} else {
							// otherwise just emit the slash as-is
							//printer.writeChar('/')
							printer.writeUnicodeCodePoint(codePoint)
						}
					} else {
						emitCodePoint(codePoint)
					}

					prevCodePoint = codePoint;
				}, s)

				printer.writeUnicodeCodePoint(0x22)
			}
		}

	let implHelper = {
		format: format,
		printerPretty: printer,
		emitEscapedQuotedStringPretty: (s) => {
			emitEscapedQuotedString(s)
		},
		printNewLine: printNewLine,
		printIndentation: printIndentation,
	} : JSONWriterPrettyImplHelper

	{
		emit: (json) => {
			let error = printElementPretty(json, implHelper, 0)

			if (format.finishWithNewLine && Option.isNone(error))
				printNewLine()
			
			error
		}
	} : JSONWriter
}

export let toString = (json: JSON, format: FormattingSettings) => {
	let buf = StringBuilder.make(16)

	let printer = makeStringBuilderPrinter(buf)
	// let printer = makeDummyPrinter()

	let writer = makePrettyPrintJSONWriter(format, printer)

	let error = writer.emit(json)

	match (error) {
		None => Ok(StringBuilder.toString(buf)),
		Some(e) => Err(e)
	}
}

export let toStringCompact = (json: JSON) => {
	let buf = StringBuilder.make(16)

	let printer = makeStringBuilderPrinter(buf)
	// let printer = makeDummyPrinter()

	let writer = makeCompactJSONWriter(printer)

	let error = writer.emit(json)

	match (error) {
		None => Ok(StringBuilder.toString(buf)),
		Some(e) => Err(e)
	}
}


export let toStringPretty = (json: JSON) => toString(json, defaultPrettyFormat())
