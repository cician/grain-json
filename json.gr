import List from "list"
import Float64 from "float64"
import { int32ToHex, unicodeCodepointToSurrogatePair, isFinite, isNaN } from "stubs"
import String from "string"
import Char from "char"
import Array from "array"
import Int32 from "int32"
import Bytes from "bytes"
import StringBuilder from "stringbuilder"
import Exception from "runtime/exception"
import Option from "option"

export enum JSON {
	JSONNull,
	JSONBoolean(Bool),
	JSONNumber(Float64),
	JSONString(String),
	// Here I've chosen to use a List and not an array as a conscious trad of performance for immutability.
	// I'd love to use a more advanced persistent collection instead, but there currently aren't any in Grain.
	JSONArray(List<JSON>),
	// Note that JSONObject here is deliberately defined as a simple list of key value pair tuples as opposed
	// to for example a Map in order to accomodate the fact that the ECMA-404 standard doesn't prohibit
	// duplicate names in Objects. Such JSON should be representable by the JSON data structure for lossless
	// processing. This also vastly simplifies implementation and has the benefit of List's immutability.
	JSONObject(List<(String,JSON)>)
}

export enum IndentationFormat {
	NoIndentation,
	IndentWithTab,
	IndentWithSpaces(Number)
}

export enum ArrayFormat {
	CompactArrayEntries,
	OneArrayEntryPerLine
}

export enum ObjectFormat {
	CompactObjectEntries,
	OneObjectEntryPerLine
}

export enum LineEnding {
	NoLineEnding,
	LineFeed,
	CarriageReturnLineFeed,
	CarriageReturn
}

export record FormattingSettings {
	indentation: IndentationFormat,
	arrayFormat: ArrayFormat,
	objectFormat: ObjectFormat,
	lineEnding: LineEnding,
	finishWithNewLine: Bool,
	escapeAllControlPoints: Bool,
	escapeHTMLUnsafeSequences: Bool,
	escapeNonASCII: Bool
}

// Compact formatting that minimizes the size of resulting JSON at cost of not being easily human readable.
// Only performs minimal string escaping as required by the ECMA-404 standard, so the result needs to
// be treated as proper unicode and is not safe to be transported in ASCII encoding.
export let defaultCompactFormat =
	() => {
		indentation: NoIndentation,
		arrayFormat: CompactArrayEntries,
		objectFormat: CompactObjectEntries,
		lineEnding: NoLineEnding,
		finishWithNewLine: false,
		escapeAllControlPoints: false,
		escapeHTMLUnsafeSequences: false,
		escapeNonASCII: false
	} : FormattingSettings

// Recommended human readable formatting.
// Escapes all control points for the sake of clarity, but doesn't go the extra mile to escape additional
// sequences or unicode characters.
export let defaultPrettyFormat =
	() => {
		indentation: IndentWithSpaces(2),
		arrayFormat: OneArrayEntryPerLine,
		objectFormat: OneObjectEntryPerLine,
		lineEnding: LineFeed,
		finishWithNewLine: true,
		escapeAllControlPoints: true,
		escapeHTMLUnsafeSequences: false,
		escapeNonASCII: false
	} : FormattingSettings

// Compact and conservative formatting to maximize compatibility and embeddability of the resulting JSON.
// Should be safe to copy and paste directly into HTML and to transported in plain ASCII.
export let defaultCompactAndSafeFormat =
	() => {
		indentation: NoIndentation,
		arrayFormat: CompactArrayEntries,
		objectFormat: CompactObjectEntries,
		lineEnding: NoLineEnding,
		finishWithNewLine: false,
		escapeAllControlPoints: true,
		escapeHTMLUnsafeSequences: true,
		escapeNonASCII: true
	} : FormattingSettings

// Pretty and conservative formatting to maximize compatibility and embeddability of the resulting JSON.
// Should be safe to copy and paste directly into HTML and to transported in plain ASCII.
export let defaultPrettyAndSafeFormat =
	() => {
		indentation: IndentWithSpaces(2),
		arrayFormat: OneArrayEntryPerLine,
		objectFormat: OneObjectEntryPerLine,
		lineEnding: LineFeed,
		finishWithNewLine: true,
		escapeAllControlPoints: true,
		escapeHTMLUnsafeSequences: true,
		escapeNonASCII: true
	} : FormattingSettings

record StringWriter {
	write: (String) -> Void,
}

let printIndentation = (indentation: IndentationFormat, writer: StringWriter, indentationLevel: Number) => {
	let write = writer.write
	match (indentation) {
		IndentWithTab => {
			let mut count = 0
			while (count < indentationLevel) {
				write("\u0009")
				count += 1;
			}
		},
		IndentWithSpaces(spacesPerIndentation) => {
			let mut count = 0
			while (count < indentationLevel*spacesPerIndentation) {
				write("\u0020")
				count += 1;
			}
		},
		NoIndentation => void
	}
}

let emitUTF16EscapeSequence = (codePoint: Int32, writer: StringWriter) => {
	// if (codePoint < 0n || codePoint > 0xFFFFn)
	// 	throw InvalidArgument("emitUTF16EscapeSequence() codePoint must be between 0 and 0xFFFF")

	let write = writer.write

	write("\\u");
	let hex = int32ToHex(codePoint)
	let mut len = String.length(hex)
	while (len < 4) {
		write("0")
		len += 1;
	}
	write(hex);
}

let emitEscapedUnicodeSequence = (codePoint: Number, writer: StringWriter) => {
	let write = writer.write

	// See the String section in the ECMA-404 doc.
	// If the code point is "in the Basic Multilingual Plane", that is
	// in range 0..65535. Greater values need to be split into two
	// UTF-16 chunks.
	let i = Int32.fromNumber(codePoint);
	if (codePoint <= 0xFFFF) {
		emitUTF16EscapeSequence(i, writer)
	} else {
		let (lowSurrogate, highSurrogate) = unicodeCodepointToSurrogatePair(codePoint)
		emitUTF16EscapeSequence(Int32.fromNumber(highSurrogate), writer)
		emitUTF16EscapeSequence(Int32.fromNumber(lowSurrogate), writer)
	}
}

let lineEndingToString = (lineEnding: LineEnding) => {
	match (lineEnding) {
		NoLineEnding => "",
		LineFeed => "\n",
		CarriageReturnLineFeed => "\r\n",
		CarriageReturn => "\r"
	}
}

// Escapes the provided string and emits the result char by char with the emit function.
let emitEscapedString = (s: String, format: FormattingSettings, writer: StringWriter) => {
	let write = writer.write

	// Escape the string.
	// Probably a good candidate for low level optimization.
	// Mostly to avoid allocating the char array.
	// Also doesn't grain allow matching on numbers?
	let chars = String.explode(s)
	let mut i = 0
	let len = Array.length(chars)
	let mut prevChar = '\u0000';
	let mut char = '\u0000';
	while (i < len) {
		char = chars[i];

		match (char) {
			'\u0008' => write("\\b"), // backspace
			'\u0009' => write("\\t"), // tab
			'\u000A' => write("\\n"), // line feed
			'\u000C' => write("\\f"), // form feed
			'\u000D' => write("\\r"), // carriage return
			'\u0022' => write("\\\""), // quotation mark
			'\u005C' => write("\\\\"), // backslash or "Reverse Solidus"
			//c => emit(toString(c))
			c => {
				let codePoint = Char.code(char);

				/*
				if (codePoint == 8) { // backspace
					emit("\\b")
				} else if (codePoint == 9) { // tab
					emit("\\t")
				} else if (codePoint == 10) { // line feed
					emit("\\n")
				} else if (codePoint == 12) { // form feed
					emit("\\f")
				} else if (codePoint == 13) { // carriage return
					emit("\\r")
				} else if (codePoint == 34) { // quotation mark
					emit("\\\"")
				} else if (codePoint == 92) { // backspace
					emit("\\\\")
				}
				*/
				
				if (codePoint >= 0 && codePoint <= 31) {
					// ASCII or "C0" control point group, except 127, handled separately.
					// The ECMA-404 spec only requires to escape the control point codes 0-31,
					// But it may be desirable to escape other control points or even everything
					// other than printable ASCII characters for compatiblity, easier transport,
					// embedding etc. Thus I've decided to expose options for this, but otherwise
					// just a sane default would suffice.
					emitEscapedUnicodeSequence(codePoint, writer)
				} else if (codePoint >= 127 && codePoint <= 159 && format.escapeAllControlPoints) {
					// ASCII control point 127 and unicode control point group C1 (128-159)
					emitEscapedUnicodeSequence(codePoint, writer)

					// There could be more control points or otherwise escape worthy codepoints,
					// but covering that would be overkill. For everything outside of the ASCII
					// range the user has to decide whether to escape all unicode codepoint or
					// nothing, including the .
				} else if (codePoint >= 128 && format.escapeNonASCII) {
					// If the user chooses to do so, escape all non ASCII code points.
					emitEscapedUnicodeSequence(codePoint, writer)
				} else if (char == '/' && format.escapeHTMLUnsafeSequences) {
					// Additionally many JSON libraries escape additional two character sequences for
					// direct embedding into html for example. This is specifically to avoid emitting
					// the sequence "</" like in "</script>".
					// The lazy approach would be to just escape the slash (which can become "\\/",
					// not necessarily "\u002F"). This more conservative approach only escapes it
					// when needed.
					if (prevChar == '<') {
						write("\\/")
					} else {
						// otherwise just emit the slash as-is
						write("/")
					}
				} else {
					write(toString(char))
				}
			}
		}

		i += 1;
		prevChar = char;
	}
}

let emitEscapedQuotedString = (s: String, format: FormattingSettings, writer: StringWriter) => {
	let write = writer.write

	write("\"")
	emitEscapedString(s, format, writer)
	write("\"")
}

export exception InvalidJSON(String)

// FIXME can't define explicit type for the emit parameter
// or am I doing something wrong?
let rec emitJSONElement = (json: JSON, format: FormattingSettings, lineEnding: String, writer: StringWriter, indentationLevel: Number) => {
	let write = writer.write

	let mut err = None : Option<Exception>;

	match (json) {
		JSONNull => write("null"),

		JSONBoolean(b) => write(if (b) "true" else "false"),

		JSONNumber(n) => {
			if (isFinite(n)) {
				// In order to not duplicate code here I simply use Grain's
				// toString of Float64. This is a bit risky because as far as I
				// can tell what it outputs is not formally documented. So
				// any changes to that could result in invalid JSON here. For
				// now at least it was considered the way to go. If one day a
				// decision is made to fork that function. The starting point
				// would be NumberUtils.dtoa and some optimizations could
				// probably be done like avoiding memory allocations or
				// checking for NaNs/Infs two times.
				write(toString(n))
			} else {
				// JSON standard doesn't allow NaN or infinite values in numbers,
				// but WASM f64 (IEEE 754-2008), as well as Grain's number types do
				// (Float64 as well as Number). This is the only reason that the
				// formatting needs to return a Result and not just a String
				// directly. Other possible choices were to throw exceptions or to
				// coninue formatting without representing these values correctly
				// (like JavaScript's JSON.stringify).
				if (isNaN(n)) {
					err = Some(InvalidJSON("NaN is not allowed in JSONNumber"))
				} else if (Float64.lt(n, Float64.fromNumber(0))) {
					err = Some(InvalidJSON("-Infinity is not allowed in JSONNumber"))
				} else {
					err = Some(InvalidJSON("Infinity is not allowed in JSONNumber"))
				}
			}
		},

		JSONString(s) => emitEscapedQuotedString(s, format, writer),

		JSONArray(elems) => {
			// Here I'm not using List.forEachi or similar in order to avoid allocations of closures.
			// The code is verbose and a bit ugly as a consequence, but I think it's an OK price for
			// [presumed] performance gain. Another approach would be to allocate a function for
			// formattng arrays just once at the start of formatting and pass it in emitJSONElement.
			
			match (elems) {
				[] => write("[]"),
				[e] => {
					write(
						match (format.arrayFormat) {
							CompactArrayEntries => "[",
							OneArrayEntryPerLine => "[ "
						}
					)
					err = emitJSONElement(e, format, lineEnding, writer, indentationLevel+1)
					if (Option.isNone(err)) {
						write(
							match (format.arrayFormat) {
								CompactArrayEntries => "]",
								OneArrayEntryPerLine => " ]"
							}
						)
					}
				},
				[initialHead, ...initialRest] => {
					write("[")
					if (format.arrayFormat == OneArrayEntryPerLine)
						write(lineEnding)

					let mut currentHead = initialHead
					let mut currentRest = initialRest

					for (let mut index = 0; ; index += 1) {
						if (index > 0) {
							write(",")
							if (format.arrayFormat == OneArrayEntryPerLine)
								write(lineEnding)
						}

						if (format.arrayFormat == OneArrayEntryPerLine)
							printIndentation(format.indentation, writer, indentationLevel+1)
						
						let elementError = emitJSONElement(currentHead, format, lineEnding, writer, indentationLevel+1)
						match(elementError) {
							None => void,
							Some(e) => {
								err = elementError
								break
							}
						}

						match (currentRest) {
							[] => break,
							[newHead, ...newRest] => {
								currentHead = newHead
								currentRest = newRest
							}
						}
					}

					if (Option.isNone(err)) {
						if (format.arrayFormat == OneArrayEntryPerLine) {
							write(lineEnding)
							printIndentation(format.indentation, writer, indentationLevel)
						}
						write("]")
					}
				}
			}
		},

		JSONObject(entries) => {
			match (entries) {
				[] => write("{}"),
				[(key, value)] => {
					write(
						match (format.objectFormat) {
							CompactObjectEntries => "{",
							OneObjectEntryPerLine => "{ "
						}
					)
					
					emitEscapedQuotedString(key, format, writer)
					write(
						match (format.objectFormat) {
							CompactObjectEntries => ":",
							OneObjectEntryPerLine => ": "
						}
					)
					err = emitJSONElement(value, format, lineEnding, writer, indentationLevel+1)

					if (Option.isNone(err)) {
						write(
							match (format.objectFormat) {
								CompactObjectEntries => "}",
								OneObjectEntryPerLine => " }"
							}
						)
					}
				},
				[initialHead, ...initialRest] => {
					write("{")
					if (format.objectFormat == OneObjectEntryPerLine)
						write(lineEnding)

					let mut currentHead = initialHead
					let mut currentRest = initialRest

					for (let mut index = 0; ; index += 1) {
						if (index > 0) {
							write(",")
							if (format.objectFormat == OneObjectEntryPerLine)
								write(lineEnding)
						}

						if (format.objectFormat == OneObjectEntryPerLine)
							printIndentation(format.indentation, writer, indentationLevel+1)

						let (key, value) = currentHead
						
						emitEscapedQuotedString(key, format, writer)
						write(
							match (format.objectFormat) {
								CompactObjectEntries => ":",
								OneObjectEntryPerLine => ": "
							}
						)
						let elementError = emitJSONElement(value, format, lineEnding, writer, indentationLevel+1)
						match(elementError) {
							None => void,
							Some(e) => {
								err = elementError
								break
							}
						}

						match (currentRest) {
							[] => break,
							[newHead, ...newRest] => {
								currentHead = newHead
								currentRest = newRest
							}
						}
					}

					if (Option.isNone(err)) {
						if (format.objectFormat == OneObjectEntryPerLine) {
							write(lineEnding)
							printIndentation(format.indentation, writer, indentationLevel)
						}
						write("}")
					}
				}
			}
		}
	}

	err
}

let emitJSON = (json: JSON, format: FormattingSettings, writer: StringWriter) => {
	let write = writer.write

	let lineEnding = lineEndingToString(format.lineEnding)

	let error = emitJSONElement(json, format, lineEnding, writer, 0)

	if (format.finishWithNewLine && Option.isNone(error))
		write(lineEnding)

	error
}

export let toString = (json: JSON, format: FormattingSettings) => {
	// If we want to be smart about limiting allocations it may make sense to
	// guesstimate the capacity by traversing the json .
	let buf = StringBuilder.make(16)

	let writer = {
		write: (s) => StringBuilder.append(s, buf)
	} : StringWriter

	let error = emitJSON(json, format, writer)

	match (error) {
		None => Ok(StringBuilder.toString(buf)),
		Some(e) => Err(e)
	}
}

export let toStringCompact = (json: JSON) => toString(json, defaultCompactFormat())

export let toStringPretty = (json: JSON) => toString(json, defaultPrettyFormat())
