import String from "string"
import Char from "char"
import List from "list"
import Option from "option"
import Number from "number"
import Exception from "runtime/exception"
import WasmI32 from "runtime/unsafe/wasmi32"
import WasmI64 from "runtime/unsafe/wasmi64"
import WasmF32 from "runtime/unsafe/wasmf32"
import WasmF64 from "runtime/unsafe/wasmf64"
import NumberUtils from "runtime/numberUtils"
import Tags from "runtime/unsafe/tags"
import Numbers from "runtime/numbers"
import Memory from "runtime/unsafe/memory"
import StringReader from "./stringreader"
import Buffer from "buffer"

export enum JSON {
  JSONNull,
  JSONBoolean(Bool),
  JSONNumber(Number),
  JSONString(String),
  // Here I've chosen to use a List and not an array as a conscious trad of performance for immutability.
  // I'd love to use a more advanced persistent collection instead, but there currently aren't any in Grain.
  JSONArray(List<JSON>),
  // Note that JSONObject here is deliberately defined as a simple list of key value pair tuples as opposed
  // to for example a Map in order to accomodate the fact that the ECMA-404 standard doesn't prohibit
  // duplicate names in Objects. Such JSON should be representable by the JSON data structure for lossless
  // processing. This also vastly simplifies implementation and has the benefit of List's immutability.
  JSONObject(List<(String,JSON)>)
}

export exception InvalidJSON(String)

export enum IndentationFormat {
  NoIndentation,
  IndentWithTab,
  IndentWithSpaces(Number)
}

export enum ArrayFormat {
  CompactArrayEntries,
  OneArrayEntryPerLine
}

export enum ObjectFormat {
  CompactObjectEntries,
  OneObjectEntryPerLine
}

export enum LineEnding {
  NoLineEnding,
  LineFeed,
  CarriageReturnLineFeed,
  CarriageReturn
}

export record FormattingSettings {
  indentation: IndentationFormat,
  arrayFormat: ArrayFormat,
  objectFormat: ObjectFormat,
  lineEnding: LineEnding,
  finishWithNewLine: Bool,
  escapeAllControlPoints: Bool,
  escapeHTMLUnsafeSequences: Bool,
  escapeNonASCII: Bool
}

// Compact formatting that minimizes the size of resulting JSON at cost of not being easily human readable.
// Only performs minimal string escaping as required by the ECMA-404 standard, so the result needs to
// be treated as proper unicode and is not safe to be transported in ASCII encoding.
export let defaultCompactFormat =
  () => {
    indentation: NoIndentation,
    arrayFormat: CompactArrayEntries,
    objectFormat: CompactObjectEntries,
    lineEnding: NoLineEnding,
    finishWithNewLine: false,
    escapeAllControlPoints: false,
    escapeHTMLUnsafeSequences: false,
    escapeNonASCII: false
  } : FormattingSettings

// Recommended human readable formatting.
// Escapes all control points for the sake of clarity, but doesn't go the extra mile to escape additional
// sequences or unicode characters.
export let defaultPrettyFormat =
  () => {
    indentation: IndentWithSpaces(2),
    arrayFormat: OneArrayEntryPerLine,
    objectFormat: OneObjectEntryPerLine,
    lineEnding: LineFeed,
    finishWithNewLine: true,
    escapeAllControlPoints: true,
    escapeHTMLUnsafeSequences: false,
    escapeNonASCII: false
  } : FormattingSettings

// Compact and conservative formatting to maximize compatibility and embeddability of the resulting JSON.
// Should be safe to copy and paste directly into HTML and to transported in plain ASCII.
export let defaultCompactAndSafeFormat =
  () => {
    indentation: NoIndentation,
    arrayFormat: CompactArrayEntries,
    objectFormat: CompactObjectEntries,
    lineEnding: NoLineEnding,
    finishWithNewLine: false,
    escapeAllControlPoints: true,
    escapeHTMLUnsafeSequences: true,
    escapeNonASCII: true
  } : FormattingSettings

// Pretty and conservative formatting to maximize compatibility and embeddability of the resulting JSON.
// Should be safe to copy and paste directly into HTML and to transported in plain ASCII.
export let defaultPrettyAndSafeFormat =
  () => {
    indentation: IndentWithSpaces(2),
    arrayFormat: OneArrayEntryPerLine,
    objectFormat: OneObjectEntryPerLine,
    lineEnding: LineFeed,
    finishWithNewLine: true,
    escapeAllControlPoints: true,
    escapeHTMLUnsafeSequences: true,
    escapeNonASCII: true
  } : FormattingSettings

record JSONWriterCompactImplHelper {
  buffer: Buffer.Buffer,
  emitEscapedQuotedString: String -> Void,
}

record JSONWriterPrettyImplHelper {
  format: FormattingSettings,
  // Note that the "Pretty" suffix here is a workaround for a Grain compiler bug.
  // It generates warnings just because two record types have some field names in common.
  // Unless there's something I don't understand about its type system.
  bufferPretty: Buffer.Buffer,
  emitEscapedQuotedStringPretty: String -> Void,
  printNewLine: () -> Void,
  printIndentation: Number -> Void,
}

// The idea for this type is to allow reusing a bit of work done in preparing for printing JSON.
// For now this is not exposed and remains an internal implementation detail.
// It may make sense in the future to expose it and let the user reuse a writer for multiple
// JSON emit operations without reallocating new closures and buffers each time.
record JSONWriter {
  emit: JSON -> Option<Exception>,
}

let addCharFromCodePoint = (codePoint: Number, buffer: Buffer.Buffer) => {
  Buffer.addChar(Char.fromCode(codePoint), buffer)
}

let emitUTF16EscapeSequence = (codePoint: Number, buffer: Buffer.Buffer) => {
  // Emit the "\u" followed by hexadecimal representation of the codepoint
  // with fixed length of 4 hexadecimal digits correspondeing to the two byte
  // codepoint. No checks are performed here if the codepoint is in the
  // "Basic Multilingual Plane" (0000-FFFF) as this funcion is only called
  // internally.
  // An alternative was to this implementation was to use NumberUtils.itoa32,
  // but I wanted to avoid unnecessary heap allocations. As a possible future
  // optimization this loop could be unrolled possibly even converted to be
  // branchless and SIMD optimized, but it could be a bit of an overkill as
  // this codepath is only for escape sequences, which probably aren't all
  // that common occurence.

  //Buffer.addChar("\\u", buffer)
  addCharFromCodePoint(92, buffer)
  addCharFromCodePoint(117, buffer)
  // Loop over the four digit from most to least significant.
  for (let mut digitIndex=3; digitIndex>=0; digitIndex -= 1) {
    // Use bit masking and shifting to extract from the codepoint a number
    // with just the bits corresponding to this hexadecinak digit.
    let shift = digitIndex * 4
    let mask = 0b1111 << shift
    let digit = (codePoint & mask) >>> shift

    // Digit now is a number in the range 0..15 and we need to translate it
    // into a unicode codepoint representing the hexacedimal digit
    // (0..9/a..f). We can use the fact that digits and latin letters in
    // ASCII and by extension in Unicode are adjacent and ordered.
    let hexDigitCodePoint =
      if (digit <= 9) {
        // 48 is codeppoint for char '0'
        digit + 48
      } else {
        // 97 is codeppoint for char 'a'
        // But we also need to subtract 10 from it because we need
        // the 10..15 number range translated to 0..5 in order to
        // serve as an index in the ASCI range 'a'..'f'.
        digit + 87
      }

    addCharFromCodePoint(hexDigitCodePoint, buffer)
  }
}

let emitEscapedUnicodeSequence = (codePoint: Number, buffer: Buffer.Buffer) => {
  // See the String section in the ECMA-404 doc.
  // If the code point is "in the Basic Multilingual Plane", that is in range
  // 0..65535. Greater values need to be split into two UTF-16 chunks.
  if (codePoint <= 0xFFFF) {
    // emitUTF16EscapeSequence(codePoint, writer)
    emitUTF16EscapeSequence(codePoint, buffer)
  } else {
    // The following three lines are copied from String module of Grain's
    // stdlib. It would be nice to share more code. On the other hand it
    // may make sense to just have these few instructions directly here
    // from the performance standpoint so we can print millions of emojis
    // per second ðŸ˜„.

    // https://en.wikipedia.org/wiki/UTF-16#Code_points_from_U+010000_to_U+10FFFF
    let uPrime = codePoint - 0x10000
    let highSurrogate = ((uPrime & 0b11111111110000000000) >>> 10) + 0xD800 // High surrogate
    let lowSurrogate = (uPrime & 0b00000000001111111111) + 0xDC00 // Low surrogate

    // emitUTF16EscapeSequence(highSurrogate, writer)
    emitUTF16EscapeSequence(highSurrogate, buffer)
    // emitUTF16EscapeSequence(lowSurrogate, writer)
    emitUTF16EscapeSequence(lowSurrogate, buffer)
  }
}

let emitEscapedCodePoint = (codePoint: Number, buffer: Buffer.Buffer) => {
  match (codePoint) {
    0x0008 => { // backspace
      //printer.write("\\b")
      addCharFromCodePoint(0x5C, buffer)
      addCharFromCodePoint(0x62, buffer)
    },
    0x0009 => { // tab
      //printer.write("\\t")
      addCharFromCodePoint(0x5C, buffer)
      addCharFromCodePoint(0x74, buffer)
    },
    0x000A => { // line feed
      //printer.write("\\n")
      addCharFromCodePoint(0x5C, buffer)
      addCharFromCodePoint(0x6E, buffer)
    },
    0x000C => { // form feed
      //printer.write("\\f")
      addCharFromCodePoint(0x5C, buffer)
      addCharFromCodePoint(0x66, buffer)
    },
    0x000D => { // carriage return
      //printer.write("\\r")
      addCharFromCodePoint(0x5C, buffer)
      addCharFromCodePoint(0x72, buffer)
    },
    0x0022 => { // quotation mark
      //printer.write("\\\"")
      addCharFromCodePoint(0x5C, buffer)
      addCharFromCodePoint(0x22, buffer)
    },
    0x005C => { // backslash or "Reverse Solidus"
      //printer.write("\\\\")
      addCharFromCodePoint(0x5C, buffer)
      addCharFromCodePoint(0x5C, buffer)
    },
    _ => {
      emitEscapedUnicodeSequence(codePoint, buffer)
    }
  }
}

let printNull = (buffer: Buffer.Buffer) => Buffer.addString("null", buffer)

let printBool = (b: Bool, buffer: Buffer.Buffer) => {
  if (b) {
    Buffer.addString("true", buffer)
  } else {
    Buffer.addString("false", buffer)
  }
}

exception UnknownNumberTag

// The following few functions are only meant to be called from a @disableGC
// context of the printNumber function so there's no need to do all the
// reference adjustment for the parameters and the functions themselves.

@disableGC
let printNumberWasmI32 = (value: WasmI32, buffer: Buffer.Buffer) => {
  let s = NumberUtils.itoa32(value, 10n)
  
  Memory.incRef(WasmI32.fromGrain(Buffer.addString))
  Memory.incRef(WasmI32.fromGrain(s))
  Memory.incRef(WasmI32.fromGrain(buffer))
  Buffer.addString(s, buffer)

  Memory.decRef(WasmI32.fromGrain(s))

  let none = None
  Memory.incRef(WasmI32.fromGrain(none))
  none
}

@disableGC
let printNumberWasmI64 = (value: WasmI64, buffer: Buffer.Buffer) => {
  let s = NumberUtils.itoa64(value, 10n)
  
  Memory.incRef(WasmI32.fromGrain(Buffer.addString))
  Memory.incRef(WasmI32.fromGrain(s))
  Memory.incRef(WasmI32.fromGrain(buffer))
  Buffer.addString(s, buffer)

  Memory.decRef(WasmI32.fromGrain(s))
  
  let none = None
  Memory.incRef(WasmI32.fromGrain(none))
  none
}

@disableGC
let isFinite = (value: WasmF64) => {
  WasmF64.eq(WasmF64.sub(value, value), 0.W)
}

@disableGC
let isNaN = (value: WasmF64) => {
  WasmF64.ne(value, value)
}

let makeNaNException = () => Some(InvalidJSON("NaN is not allowed in JSONNumber"))

let makeInfException = () => Some(InvalidJSON("Infinity is not allowed in JSONNumber"))

let makeNegInfException = () => Some(InvalidJSON("-Infinity is not allowed in JSONNumber"))

@disableGC
let printNumberWasmF64 = (value: WasmF64, buffer: Buffer.Buffer) => {
  let result = if (isFinite(value)) {
      let s = NumberUtils.dtoa(value)
      
      Memory.incRef(WasmI32.fromGrain(Buffer.addString))
      Memory.incRef(WasmI32.fromGrain(s))
      Memory.incRef(WasmI32.fromGrain(buffer))
      Buffer.addString(s, buffer)

      Memory.decRef(WasmI32.fromGrain(s))

      let none = None
      Memory.incRef(WasmI32.fromGrain(none))
      none
    } else {
      // JSON standard doesn't allow NaN or infinite values in numbers,
      // but WASM f64 (IEEE 754-2008), as well as Grain's number types do
      // (Float64 as well as Number). This is the only reason that the
      // formatting needs to return a Result and not just a String
      // directly. Other possible choices were to throw exceptions or to
      // coninue formatting without representing these values correctly
      // (like JavaScript's JSON.stringify).
      if (isNaN(value)) {
        // Allocating the exception in a function without @disableGC makes
        // it easier to avoid problems with reference counting.
        makeNaNException()
      } else if (WasmF64.lt(value, 0.0W)) {
        makeNegInfException()
      } else {
        makeInfException()
      }
    }

  result
}

@disableGC
let rec printNumber = (value: Number, buffer: Buffer.Buffer) => {
  let (&) = WasmI32.and
  let (==) = WasmI32.eq
  let (!=) = WasmI32.ne
  let (<<) = WasmI32.shl
  let (>>) = WasmI32.shrS

  let ptr = WasmI32.fromGrain(value)
  let result = if ((ptr & 1n) != 0n) {
    // FIXME expose runtime/numbers.untagSimple?
    let asWasmI32 = ptr >> 1n
    printNumberWasmI32(asWasmI32, buffer)
  } else if ((ptr & 7n) == Tags._GRAIN_GENERIC_HEAP_TAG_TYPE) {
    let tag = WasmI32.load(ptr, 0n)
    match (tag) {
      t when t == Tags._GRAIN_BOXED_NUM_HEAP_TAG => {
        let numberTag = WasmI32.load(ptr, 4n)
        match (numberTag) {
          t when t == Tags._GRAIN_INT32_BOXED_NUM_TAG => {
            let asWasmI32 = WasmI32.load(ptr, 8n) // FIXME magic numbers
            printNumberWasmI32(asWasmI32, buffer)
          },
          t when t == Tags._GRAIN_INT64_BOXED_NUM_TAG => {
            let asWasmI64 = WasmI64.load(ptr, 8n) // FIXME magic numbers
            printNumberWasmI64(asWasmI64, buffer)
          },
          t when t == Tags._GRAIN_RATIONAL_BOXED_NUM_TAG => {
            // As a compromnise, convert the rational into a float
            // and then print that. This means there can be
            // precision loss even for values that could be printed
            // exactly in decimal notation, but doing otherwise
            // could both compromise perfomance and confuse
            // developers as most JSON libraries in other languages
            // likely only deal with integers and floats.
            // Note that the ECMA-404 standard only specifies how
            // numbers should be formatted as text (in decimal
            // notation), so we could go the extra mile and at
            // least for some numbers try printing the exact
            // number. For example those that have a power of 10
            // in the denominator.
            let asWasmF64 = WasmF64.div(WasmF64.convertI32S(Numbers.boxedRationalNumerator(ptr)), WasmF64.convertI32S(Numbers.boxedRationalDenominator(ptr)))

            printNumberWasmF64(asWasmF64, buffer)
          },
          t when t == Tags._GRAIN_FLOAT32_BOXED_NUM_TAG => {
            let asWasmF32 = WasmF32.load(ptr, 8n) // FIXME magic numbers
            let asWasmF64 = WasmF64.promoteF32(asWasmF32)
            printNumberWasmF64(asWasmF64, buffer)
          },
          t when t == Tags._GRAIN_FLOAT64_BOXED_NUM_TAG => {
            let asWasmF64 = WasmF64.load(ptr, 8n) // FIXME magic numbers
            printNumberWasmF64(asWasmF64, buffer)
          },
          _ => {
            throw UnknownNumberTag
          }
        }
      },
      _ => {
        throw UnknownNumberTag
      }
    }
  } else {
    throw UnknownNumberTag
  }
  
  Memory.decRef(WasmI32.fromGrain(value))
  Memory.decRef(WasmI32.fromGrain(buffer))
  Memory.decRef(WasmI32.fromGrain(printNumber))

  result
}

// Note that this function is not allocated with the JSONWriter because currently
// Grain leaks memory each time a recursive closure is allocated. Not reallocating
// it may also be a better thing to do.
let rec printElementCompact = (json: JSON, implHelper: JSONWriterCompactImplHelper) => {
  let buffer = implHelper.buffer
  match (json) {
    JSONNull => {
      printNull(buffer)
      None
    },
    JSONBoolean(b) => {
      printBool(b, buffer)
      None
    },
    JSONNumber(n) => printNumber(n, buffer),
    JSONString(s) => {
      implHelper.emitEscapedQuotedString(s)
      None
    },
    JSONArray(elems) => {
      // Here I'm not using List.forEachi or similar in order to avoid
      // allocations of closures. The code is verbose and a bit ugly as a
      // consequence, but I think it's an OK price for performance gain.
      // Another approach would be to allocate a function for the
      // formattng arrays just once at the start of formatting and pass
      // it in emitJSONElement.
      match (elems) {
        [] => {
          //printer.write("[]")
          addCharFromCodePoint(0x5B, buffer)
          addCharFromCodePoint(0x5D, buffer)
          None
        },
        [e] => {
          //printer.write("[")
          addCharFromCodePoint(0x5B, buffer)
        
          let err = printElementCompact(e, implHelper)

          if (Option.isNone(err)) {
            //printer.write("]")
            addCharFromCodePoint(0x5D, buffer)
          }

          err
        },
        [initialHead, ...initialRest] => {
          // printer.write("[")
          addCharFromCodePoint(0x5B, buffer)

          let mut currentHead = initialHead
          let mut currentRest = initialRest

          let mut err = None

          for (let mut index = 0; ; index += 1) {
            if (index > 0) {
              // printer.write(",")
              addCharFromCodePoint(0x2C, buffer)
            }

            err = printElementCompact(currentHead, implHelper)
            if (Option.isSome(err))
              break

            match (currentRest) {
              [] => break,
              [newHead, ...newRest] => {
                currentHead = newHead
                currentRest = newRest
              }
            }
          }

          if (Option.isNone(err)) {
            // printer.write("]")
            addCharFromCodePoint(0x5D, buffer)
          }

          err
        }
      }
    },
    JSONObject(entries) => {
      match (entries) {
        [] => {
          // printer.write("{}")
          addCharFromCodePoint(0x7B, buffer)
          addCharFromCodePoint(0x7D, buffer)
          None
        },
        [(key, value)] => {
          //printer.writeChar('{')
          addCharFromCodePoint(0x7B, buffer)
          
          implHelper.emitEscapedQuotedString(key)

          //printer.writeChar(':')
          addCharFromCodePoint(0x3A, buffer)

          let err = printElementCompact(value, implHelper)

          if (Option.isNone(err)) {
            // printer.writeChar('}')
            addCharFromCodePoint(0x7D, buffer)
          }
          
          err
        },
        [initialHead, ...initialRest] => {
          // printer.writeChar('{')
          addCharFromCodePoint(0x7B, buffer)

          let mut currentHead = initialHead
          let mut currentRest = initialRest

          let mut err = None

          for (let mut index = 0; ; index += 1) {
            if (index > 0) {
              // printer.write(",")
              addCharFromCodePoint(0x2C, buffer)
            }

            let (key, value) = currentHead
            
            implHelper.emitEscapedQuotedString(key)

            //printer.writeChar(':')
            addCharFromCodePoint(0x3A, buffer)
            
            err = printElementCompact(value, implHelper)

            if (Option.isSome(err))
              break

            match (currentRest) {
              [] => break,
              [newHead, ...newRest] => {
                currentHead = newHead
                currentRest = newRest
              }
            }
          }

          if (Option.isNone(err)) {
            // printer.writeChar('}')
            addCharFromCodePoint(0x7D, buffer)
          }

          err
        }
      }
    }
  }
}

let makeCompactJSONWriter = (buffer: Buffer.Buffer) => {
  // As an optimization prepare a closure function to execute for each code
  // point of the input. It's important that this is not inlide in the
  // emitEscapedQuotedString function directly to avoid allocating the closue
  // for each input string.
  let emitCodePoint = (codePoint: Number) => {
    // For the compact formatting only escape backslash, double quotes and
    // code points 0..31 (the so called "C0" control point group) as
    // required by ECMA-404. For the non pretty printed case we don't want
    // to escape more than what is stricty required to avoid increasing the
    // output size.
    if (codePoint > 31 && codePoint != 0x0022 && codePoint != 0x005C) {
      addCharFromCodePoint(codePoint, buffer)
    } else {
      emitEscapedCodePoint(codePoint, buffer)
    }
  }
  
  let emitEscapedQuotedString = (s: String) => {
    //printer.write("\"")
    addCharFromCodePoint(0x22, buffer)

    String.forEachCodePoint(emitCodePoint, s)

    //printer.write("\"")
    addCharFromCodePoint(0x22, buffer)
  }

  let implHelper = {
    buffer: buffer,
    emitEscapedQuotedString: (s) => {
      emitEscapedQuotedString(s)
    },
  } : JSONWriterCompactImplHelper

  {
    emit: (json) => {
      let error = printElementCompact(json, implHelper)

      error
    },
  } : JSONWriter
}

// Note that this could relatively easily be integrated with
// printElementCompact to avoid code duplication, but it would mean
// compromising peak performance and also increasing complexity in other ways.
let rec printElementPretty = (json: JSON, implHelper: JSONWriterPrettyImplHelper, indentationLevel: Number) => {
  let buffer = implHelper.bufferPretty
  match (json) {
    JSONNull => {
      printNull(buffer)
      None
    },
    JSONBoolean(b) => {
      printBool(b, buffer)
      None
    },
    JSONNumber(n) => printNumber(n, buffer),
    JSONString(s) => {
      implHelper.emitEscapedQuotedStringPretty(s)
      None
    },
    JSONArray(elems) => {
      match (elems) {
        [] => {
          //printer.write("[]")
          addCharFromCodePoint(0x5B, buffer)
          addCharFromCodePoint(0x5D, buffer)
          None
        },
        [e] => {
          let format = implHelper.format

          //printer.write("[")
          addCharFromCodePoint(0x5B, buffer)

          if (format.arrayFormat == OneArrayEntryPerLine)
            implHelper.printNewLine()

          let elemLevel = indentationLevel+1
        
          if (format.arrayFormat == OneArrayEntryPerLine)
            implHelper.printIndentation(elemLevel)
        
          let err = printElementPretty(e, implHelper, elemLevel)

          if (Option.isNone(err)) {
            if (format.arrayFormat == OneArrayEntryPerLine) {
              implHelper.printNewLine()
              implHelper.printIndentation(indentationLevel)
            }
            
            //printer.write("]")
            addCharFromCodePoint(0x5D, buffer)
          }

          err
        },
        [initialHead, ...initialRest] => {
          let format = implHelper.format

          // printer.write("[")
          addCharFromCodePoint(0x5B, buffer)

          if (format.arrayFormat == OneArrayEntryPerLine)
            implHelper.printNewLine()

          let mut currentHead = initialHead
          let mut currentRest = initialRest

          let mut err = None

          let elemLevel = indentationLevel+1

          for (let mut index = 0; ; index += 1) {
            if (index > 0) {
              // printer.write(",")
              addCharFromCodePoint(0x2C, buffer)

              if (format.arrayFormat == OneArrayEntryPerLine)
                implHelper.printNewLine()
            }

            if (format.arrayFormat == OneArrayEntryPerLine)
              implHelper.printIndentation(elemLevel)

            err = printElementPretty(currentHead, implHelper, elemLevel)
            if (Option.isSome(err))
              break

            match (currentRest) {
              [] => break,
              [newHead, ...newRest] => {
                currentHead = newHead
                currentRest = newRest
              }
            }
          }

          if (Option.isNone(err)) {
            if (format.arrayFormat == OneArrayEntryPerLine) {
              implHelper.printNewLine()
              implHelper.printIndentation(indentationLevel)
            }
            
            // printer.write("]")
            addCharFromCodePoint(0x5D, buffer)
          }

          err
        }
      }
    },
    JSONObject(entries) => {
      match (entries) {
        [] => {
          // printer.write("{}")
          addCharFromCodePoint(0x7B, buffer)
          addCharFromCodePoint(0x7D, buffer)
          None
        },
        [(key, value)] => {
          let format = implHelper.format

          //printer.writeChar('{')
          addCharFromCodePoint(0x7B, buffer)

          let elemLevel = indentationLevel+1

          if (format.objectFormat == OneObjectEntryPerLine) {
            implHelper.printNewLine()
            implHelper.printIndentation(elemLevel)
          }
          
          implHelper.emitEscapedQuotedStringPretty(key)

          match (format.objectFormat) {
            CompactObjectEntries => {
              //printer.writeChar(':')
              addCharFromCodePoint(0x3A, buffer)
            },
            OneObjectEntryPerLine => {
              //printer.writeChar(':')
              addCharFromCodePoint(0x3A, buffer)
              addCharFromCodePoint(0x20, buffer)
            }
          }

          let err = printElementPretty(value, implHelper, elemLevel)

          if (Option.isNone(err)) {
            if (format.objectFormat == OneObjectEntryPerLine) {
              implHelper.printNewLine()
              implHelper.printIndentation(indentationLevel)
            }
            
            // printer.writeChar('}')
            addCharFromCodePoint(0x7D, buffer)
          }
          
          err
        },
        [initialHead, ...initialRest] => {
          let format = implHelper.format

          // printer.writeChar('{')
          addCharFromCodePoint(0x7B, buffer)

          if (format.objectFormat == OneObjectEntryPerLine)
            implHelper.printNewLine()

          let mut currentHead = initialHead
          let mut currentRest = initialRest

          let mut err = None

          let elemLevel = indentationLevel+1

          for (let mut index = 0; ; index += 1) {
            if (index > 0) {
              // printer.write(",")
              addCharFromCodePoint(0x2C, buffer)

              if (format.objectFormat == OneObjectEntryPerLine)
                implHelper.printNewLine()
            }

            if (format.objectFormat == OneObjectEntryPerLine)
              implHelper.printIndentation(elemLevel)

            let (key, value) = currentHead
            
            implHelper.emitEscapedQuotedStringPretty(key)

            match (format.objectFormat) {
              CompactObjectEntries => {
                //printer.writeChar(':')
                addCharFromCodePoint(0x3A, buffer)
              },
              OneObjectEntryPerLine => {
                //printer.write(": ")
                addCharFromCodePoint(0x3A, buffer)
                addCharFromCodePoint(0x20, buffer)
              }
            }
            
            err = printElementPretty(value, implHelper, elemLevel)

            if (Option.isSome(err))
              break

            match (currentRest) {
              [] => break,
              [newHead, ...newRest] => {
                currentHead = newHead
                currentRest = newRest
              }
            }
          }

          if (Option.isNone(err)) {
            if (format.objectFormat == OneObjectEntryPerLine) {
              implHelper.printNewLine()
              implHelper.printIndentation(indentationLevel)
            }
            
            // printer.writeChar('}')
            addCharFromCodePoint(0x7D, buffer)
          }

          err
        }
      }
    }
  }
}

let isHighSurrogate = (code: Number) => code >= 0xD800 && code <= 0xDBFF

let isLowSurrogate = (code: Number) => code >= 0xDC00 && code <= 0xDFFF

let combineSurrogatePairToCodePoint = (highSurrogate: Number, lowSurrogate: Number) => {
  // If this was a method exposed by itself in a library then it should check the
  // ranges of the input surrogates, but here it's necessary because checks are made
  // as part of the parsing logic.
  ((highSurrogate - 0xD800) << 10) + (lowSurrogate - 0xDC00) + 0x10000
}

let makePrettyPrintJSONWriter = (format: FormattingSettings, buffer: Buffer.Buffer) => {
  let printNewLine = match (format.lineEnding) {
    NoLineEnding => () => void,
    LineFeed => () => {
      //printer.writeChar('\n')
      addCharFromCodePoint(0x0A, buffer)
    },
    CarriageReturnLineFeed => () => {
      //printer.write("\r\n")
      addCharFromCodePoint(0x0D, buffer)
      addCharFromCodePoint(0x0A, buffer)
    },
    CarriageReturn => () => {
      //printer.writeChar('\r')
      addCharFromCodePoint(0x0D, buffer)
    },
  }
  
  let printIndentation = match (format.indentation) {
    IndentWithTab => (indentationLevel) => {
      let mut count = 0
      while (count < indentationLevel) {
        //printer.writeChar('\t')
        addCharFromCodePoint(0x09, buffer)
        count += 1
      }
    },
    IndentWithSpaces(spacesPerIndentation) => (indentationLevel) => {
      let mut count = 0
      let spaceCount = indentationLevel*spacesPerIndentation
      while (count < spaceCount) {
        //printer.writeChar(' ')
        addCharFromCodePoint(0x20, buffer)
        count += 1
      }
    },
    NoIndentation => (indentationLevel) => void
  }

  // FIXME the if expressions below leak memory (https://github.com/grain-lang/grain/issues/774)

  // As an optimization prepare a different closure function for each
  // combination of escaping options. This ways we can avoid unnecessary
  // branching in the code executed for each character. What is most
  // important here is to optimize for the non pretty printed format as this
  // is where the performance is most likely to matter. In every case escape
  // code points 0..31 as required by ECMA-404 (the so called "C0" control
  // point group). For the non pretty printed case we don't want to escape
  // more than what is stricty required to avoid increasing the output size.
  // But for pretty printing or compatiblity it may be desirable to escape
  // other control points or even everything other than printable ASCII
  // characters. Thus I've decided to expose options for this, but otherwise
  // just a sane default would suffice.
  // Additionally many JSON libraries escape additional two character
  // sequences for direct embedding into html for example. This is
  // specifically to avoid emitting the sequence "</" like in "</script>".
  // The lazy approach would be to just escape the slash (which can become
  // "\\/", not necessarily "\u002F"). This more conservative approach only
  // escapes it when needed, but requires to keep track of the previous code
  // point in the iteration so it's more complicated and handled separately.
  let emitCodePoint =
    if (!format.escapeAllControlPoints && !format.escapeNonASCII) {
      (codePoint: Number) => {
        if (codePoint > 31 && codePoint != 0x0022 && codePoint != 0x005C) {
          addCharFromCodePoint(codePoint, buffer)
        } else {
          emitEscapedCodePoint(codePoint, buffer)
        }
      }
    } else if (!format.escapeAllControlPoints && format.escapeNonASCII) {
      // If desired, escape all non ASCII code points. So the only non
      // escaped code points are those in the range of ASCII chacarcters
      // from 31 to 127.
      (codePoint: Number) => {
        if (codePoint > 31 && codePoint != 0x0022 && codePoint != 0x005C && codePoint < 128) {
          addCharFromCodePoint(codePoint, buffer)
        } else {
          emitEscapedCodePoint(codePoint, buffer)
        }
      }
    } else if (format.escapeAllControlPoints && !format.escapeNonASCII) {
      // If desired, in addition to the required 0..31 control points,
      // also escape unicode control point group C1 (128-159).
      // There could be more control points or otherwise escape worthy
      // codepoints, but covering that would be overkill.
      (codePoint: Number) => {
        if ((codePoint > 31 && codePoint != 0x0022 && codePoint != 0x005C && codePoint < 127) || codePoint > 159) {
          addCharFromCodePoint(codePoint, buffer)
        } else {
          emitEscapedCodePoint(codePoint, buffer)
        }
      }
    } else {
      // And this is just the combination of both flags, which means
      // doing almost the same as for the case above for
      // escapeNonASCII=true, but also escape the ASCII control codepoint
      // 127 (Delete).
      (codePoint: Number) => {
        if (codePoint > 31 && codePoint != 0x0022 && codePoint != 0x005C && codePoint < 127) {
          // fast path for chars that never need any escaping
          addCharFromCodePoint(codePoint, buffer)
        } else {
          emitEscapedCodePoint(codePoint, buffer)
        }
      }
    }
  
  let emitEscapedQuotedString =
    if (!format.escapeHTMLUnsafeSequences) {
      (s: String) => {
        //printer.write("\"")
        addCharFromCodePoint(0x22, buffer)

        // Note that it's important for performance that the closure passed to forEachCodePoint
        // is not allocated inline here, but just once when creating the writer.
        
        String.forEachCodePoint(emitCodePoint, s)

        //printer.write("\"")
        addCharFromCodePoint(0x22, buffer)
      }
    } else {
      // Special handling for the escapeHTMLUnsafeSequences flag.
      // Escaping a sequence requires keeping track of previous characters,
      // which is difficult and suboptimal when using a function to iterate
      // the input string. So we don't want to pay the price in other cases.
      // This cannot be done just in the emitCodePoint function.
      // It could be possible to implement more optimally, but would
      // complicate things even more than this.
      (s: String) => {
        addCharFromCodePoint(0x22, buffer)

        let mut prevCodePoint = 0

        String.forEachCodePoint((codePoint) => {
          if (codePoint == 47) {
            if (format.escapeHTMLUnsafeSequences && prevCodePoint == 60) {
              //printer.write("\\/")
              addCharFromCodePoint(92, buffer)
              addCharFromCodePoint(47, buffer)
            } else {
              // otherwise just emit the slash as-is
              //printer.writeChar('/')
              addCharFromCodePoint(codePoint, buffer)
            }
          } else {
            emitCodePoint(codePoint)
          }

          prevCodePoint = codePoint
        }, s)

        addCharFromCodePoint(0x22, buffer)
      }
    }

  let implHelper = {
    format: format,
    bufferPretty: buffer,
    emitEscapedQuotedStringPretty: (s) => {
      emitEscapedQuotedString(s)
    },
    printNewLine: printNewLine,
    printIndentation: printIndentation,
  } : JSONWriterPrettyImplHelper

  {
    emit: (json) => {
      let error = printElementPretty(json, implHelper, 0)

      if (format.finishWithNewLine && Option.isNone(error))
        printNewLine()
      
      error
    }
  } : JSONWriter
}

export let toString = (json: JSON, format: FormattingSettings) => {
  let buf = Buffer.make(16)

  let writer = makePrettyPrintJSONWriter(format, buf)

  let error = writer.emit(json)

  match (error) {
    None => Ok(Buffer.toString(buf)),
    Some(e) => Err(e)
  }
}

export let toStringCompact = (json: JSON) => {
  let buf = Buffer.make(16)

  let writer = makeCompactJSONWriter(buf)

  let error = writer.emit(json)

  match (error) {
    None => Ok(Buffer.toString(buf)),
    Some(e) => Err(e)
  }
}

record JSONParserImplHelper {
  reader: StringReader.StringReader,
  mut currentCodePoint: Number,
  mut pos: Number
}

export exception UnexpectedEndOfInput

export exception UnexpectedToken(Char, Number)

export let toStringPretty = (json: JSON) => toString(json, defaultPrettyFormat())

let isInterTokenWhiteSpace = (codePoint: Number) => {
  match (codePoint) {
    0x0009 => true, // tab
    0x000A => true, // line feed
    0x000D => true, // carriage return
    0x0020 => true, // space
    _ => false
  }
}

let _END_OF_INPUT = -1

let isAtEndOfInput = (parserImplHelper: JSONParserImplHelper) => {
  parserImplHelper.currentCodePoint == _END_OF_INPUT
}

let next = (parserImplHelper: JSONParserImplHelper) => {
  let c = StringReader.readCodePointFast(parserImplHelper.reader)
  parserImplHelper.currentCodePoint = c
  parserImplHelper.pos = parserImplHelper.pos + 1
  c
}

let skipWhiteSpace = (parserImplHelper: JSONParserImplHelper) => {
  // isAtEndOfInput is not strictly necessary here
  // could remove as an optimization
  while (isInterTokenWhiteSpace(parserImplHelper.currentCodePoint) && !isAtEndOfInput(parserImplHelper)) {
    next(parserImplHelper)
    void
  }
}

let buildUnexpectedTokenError = (parserImplHelper: JSONParserImplHelper) => {
  let codePoint = parserImplHelper.currentCodePoint
  if (codePoint == _END_OF_INPUT) {
    UnexpectedEndOfInput
  } else {
    let char = Char.fromCode(parserImplHelper.currentCodePoint)
    let pos = parserImplHelper.pos
    UnexpectedToken(char, pos)
  }
}

let expectCodePointAndAdvance = (expectedCodePoint: Number, parserImplHelper: JSONParserImplHelper) => {
  let c = parserImplHelper.currentCodePoint
  if (c == expectedCodePoint) {
    next(parserImplHelper)
    None
  } else {
    Some(buildUnexpectedTokenError(parserImplHelper))
  }
}

let rec parseValue = (parserImplHelper: JSONParserImplHelper) => {
  skipWhiteSpace(parserImplHelper)

    let result = match (parserImplHelper.currentCodePoint) {
    0x7B => parseObject(parserImplHelper), // '{'
    0x5B => parseArray(parserImplHelper), // '['
    0x22 => parseStringValue(parserImplHelper), // '"'
    0x74 => parseTrueValue(parserImplHelper), // 't'
    0x66 => parseFalseValue(parserImplHelper), // 'f'
    0x6E => parseNullValue(parserImplHelper), // 'n'
    // TODO Check if having a match case for each digit would be faster or not.
    c when (c >= 0x30 && c <= 0x39) || c == 0x2D => parseNumberValue(parserImplHelper), // '0'..'9' or '-'
    c => {
      Err(buildUnexpectedTokenError(parserImplHelper))
    }
  }

  skipWhiteSpace(parserImplHelper)

  result
}
, parseNullValue = (parserImplHelper: JSONParserImplHelper) => {
  match (expectCodePointAndAdvance(0x6E, parserImplHelper)) { // 'n'
    Some(e) => Err(e),
    None => {
      match (expectCodePointAndAdvance(0x75, parserImplHelper)) { // 'u'
        Some(e) => Err(e),
        None => {
          match (expectCodePointAndAdvance(0x6C, parserImplHelper)) { // 'l'
            Some(e) => Err(e),
            None => {
              match (expectCodePointAndAdvance(0x6C, parserImplHelper)) { // 'l'
                Some(e) => Err(e),
                None => Ok(JSONNull)
              }
            }
          }
        }
      }
    }
  }
}
, parseTrueValue = (parserImplHelper: JSONParserImplHelper) => {
  match (expectCodePointAndAdvance(0x74, parserImplHelper)) { // 't'
    Some(e) => Err(e),
    None => {
      match (expectCodePointAndAdvance(0x72, parserImplHelper)) { // 'r'
        Some(e) => Err(e),
        None => {
          match (expectCodePointAndAdvance(0x75, parserImplHelper)) { // 'u'
            Some(e) => Err(e),
            None => {
              match (expectCodePointAndAdvance(0x65, parserImplHelper)) { // 'e'
                Some(e) => Err(e),
                None => Ok(JSONBoolean(true))
              }
            }
          }
        }
      }
    }
  }
}
, parseFalseValue = (parserImplHelper: JSONParserImplHelper) => {
  match (expectCodePointAndAdvance(0x66, parserImplHelper)) { // 'f'
    Some(e) => Err(e),
    None => {
      match (expectCodePointAndAdvance(0x61, parserImplHelper)) { // 'a'
        Some(e) => Err(e),
        None => {
          match (expectCodePointAndAdvance(0x6C, parserImplHelper)) { // 'l'
            Some(e) => Err(e),
            None => {
              match (expectCodePointAndAdvance(0x73, parserImplHelper)) { // 's'
                Some(e) => Err(e),
                None => {
                  match (expectCodePointAndAdvance(0x65, parserImplHelper)) { // 'e'
                    Some(e) => Err(e),
                    None => Ok(JSONBoolean(false))
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}
, parseString = (parserImplHelper: JSONParserImplHelper) => {
  // TODO Reuse the buffer for each string.
  // This is first implementation to just keep going with overall
  // parsing code and will need to be revised... For now no escape
  // handling at all!
  match (expectCodePointAndAdvance(0x22, parserImplHelper)) { // '"'
    Some(e) => Err(e),
    None => {
      let mut err = None
      let mut done = false
      let buffer = Buffer.make(16)

      let mut prevHighSurrogate = -1 // not using Option here to avoid heap allocations.

      while (!done) {
        match (parserImplHelper.currentCodePoint) {
          0x22 => { // '"'
            next(parserImplHelper)
            if (prevHighSurrogate != -1) {
              addCharFromCodePoint(prevHighSurrogate, buffer)
              prevHighSurrogate = -1
            }
            done = true
            break
          },
          -1 => {
            // just end the loop without setting done to true
            break
          },
          0x5C => { // '\'
            next(parserImplHelper)

            match (parserImplHelper.currentCodePoint) {
              0x22 => { // '"'
                addCharFromCodePoint(0x22, buffer)
                next(parserImplHelper)
                if (prevHighSurrogate != -1) {
                  addCharFromCodePoint(prevHighSurrogate, buffer)
                  prevHighSurrogate = -1
                }
              },
              0x5C => { // '\'
                addCharFromCodePoint(0x5C, buffer)
                next(parserImplHelper)
                if (prevHighSurrogate != -1) {
                  addCharFromCodePoint(prevHighSurrogate, buffer)
                  prevHighSurrogate = -1
                }
              },
              0x2F => { // '/'
                addCharFromCodePoint(0x2F, buffer)
                next(parserImplHelper)
                if (prevHighSurrogate != -1) {
                  addCharFromCodePoint(prevHighSurrogate, buffer)
                  prevHighSurrogate = -1
                }
              },
              0x62 => { // letter 'b' as in Backspace
                // emit backspace control code
                addCharFromCodePoint(0x08, buffer)
                next(parserImplHelper)
                if (prevHighSurrogate != -1) {
                  addCharFromCodePoint(prevHighSurrogate, buffer)
                  prevHighSurrogate = -1
                }
              },
              0x66 => { // letter 'f' as in Form Feed
                // emit Form Feed control code
                addCharFromCodePoint(0x0C, buffer)
                next(parserImplHelper)
                if (prevHighSurrogate != -1) {
                  addCharFromCodePoint(prevHighSurrogate, buffer)
                  prevHighSurrogate = -1
                }
              },
              0x6E => { // letter 'n' as in New line
                // emit Line Feed control code
                addCharFromCodePoint(0x0A, buffer)
                next(parserImplHelper)
                if (prevHighSurrogate != -1) {
                  addCharFromCodePoint(prevHighSurrogate, buffer)
                  prevHighSurrogate = -1
                }
              },
              0x72 => { // letter 'r' as in carriage Return
                // emit Carriage Return control code
                addCharFromCodePoint(0x0D, buffer)
                next(parserImplHelper)
                if (prevHighSurrogate != -1) {
                  addCharFromCodePoint(prevHighSurrogate, buffer)
                  prevHighSurrogate = -1
                }
              },
              0x74 => { // letter 't' as in Tab
                // emit Tab control code
                addCharFromCodePoint(0x09, buffer)
                next(parserImplHelper)
                if (prevHighSurrogate != -1) {
                  addCharFromCodePoint(prevHighSurrogate, buffer)
                  prevHighSurrogate = -1
                }
              },
              0x75 => { // 'u' (start of hexadecimal UTF-16 escape sequence)
                next(parserImplHelper)

                let mut codePoint = 0
                for (let mut digitIndex=3; digitIndex>=0; digitIndex -= 1) {
                  let hexDigitCodePoint = parserImplHelper.currentCodePoint
                  
                  let mut digit = hexDigitCodePoint

                  if (hexDigitCodePoint >= 48 && hexDigitCodePoint <= 57) { // 0..9
                    digit -= 48
                  } else if (hexDigitCodePoint >= 65 && hexDigitCodePoint <= 70) { // A..F
                    digit -= 55 // (65 - 10)
                  } else if (hexDigitCodePoint >= 97 && hexDigitCodePoint <= 102) { // a..f
                    digit -= 87 // (97 - 10)
                  } else {
                    err = Some(buildUnexpectedTokenError(parserImplHelper))
                    break
                  }
                  
                  let shift = digitIndex * 4
                  codePoint = codePoint | (digit << shift)

                  next(parserImplHelper)
                  void
                }

                match (err) {
                  None => {
                    if (isHighSurrogate(codePoint)) {
                      // Don't emit the codepoint yet.
                      // It's part of a UTF-16 surrogate pair and needs to be combined
                      // with whatever escaped codepoint comes next.
                      // Which is easier said than done becase the JSON may not be well
                      // formatted and not have one. In which case we want to mimick
                      // the behaviour of node.js and browsers, that continue to parse
                      // and just keep the single surrogate. Which is kinda wrong, if you ask me, but doing otherwise may be unwise.
                      // The ECMA-404 spec is very loose about these things.
                      prevHighSurrogate = codePoint
                    } else {
                      if (prevHighSurrogate != -1) {
                        if (isLowSurrogate(codePoint)) {
                          let lowSurrogate = codePoint
                          let combinedCodePoint = combineSurrogatePairToCodePoint(prevHighSurrogate, lowSurrogate)
                          
                          addCharFromCodePoint(combinedCodePoint, buffer)
                        } else {
                          // There's a previous high surrogate not yet written to the buffer,
                          // but the following escaped codepoint is not a low surrogate.
                          // This is invalid pairing, but we want to just take both as-is.
                          addCharFromCodePoint(prevHighSurrogate, buffer)
                          addCharFromCodePoint(codePoint, buffer)
                        }

                        prevHighSurrogate = -1
                      } else {
                        // No previous surrogate to combine. Just take the code point as-is, whether a proper codepoint or an invalid surrogate.
                        addCharFromCodePoint(codePoint, buffer)
                      }
                    }
                  },
                  _ => {
                    break
                  }
                }
              },
              _ => {
                // JSON doesn't allow arbitrary characters to be preceded by backslash escape.
                // Only the ones above.
                err = Some(buildUnexpectedTokenError(parserImplHelper))
                break
              }
            }
          },
          c => {
            // Finally the happy case of a simple unescaped code point.
            next(parserImplHelper)
            addCharFromCodePoint(c, buffer)
            if (prevHighSurrogate != -1) {
              addCharFromCodePoint(prevHighSurrogate, buffer)
              prevHighSurrogate = -1
            }
          }
        }
      }

      match (err) {
        None => {
          if (done) {
            let s = Buffer.toString(buffer)
            Ok(s)
          } else {
            Err(buildUnexpectedTokenError(parserImplHelper))
          }
        },
        Some(e) => Err(e)
      }
    }
  }
}
, parseStringValue = (parserImplHelper: JSONParserImplHelper) => {
  match (parseString(parserImplHelper)) {
    Ok(s) => Ok(JSONString(s)),
    Err(e) => Err(e)
  }
}
, parseNumberValue = (parserImplHelper: JSONParserImplHelper) => {
  // First char can optionally be a minus sign.
  let mut c = parserImplHelper.currentCodePoint
  let isNegative = c == 0x2D  // '-'
  if (isNegative) {
    c = next(parserImplHelper)
  }

  let mut err = None

  let mut significand = 0
  let mut exponent = 0
  let mut isExponentNegative = false

  // Note on performance: the hope here is to keep calculations in a way to
  // do at least the intermediate operations with Simple Numbers (non heap
  // allocated). If there's no fractional part then the resulting number
  // itself is packed into the "pointer" / value and only an instance of
  // JSONNumber is allocated on the heap. If the number has a fractional part
  // or a negative exponent then the final number will be heap allocated.
  // If the number doesn't fit 31 bits then intermetdiate calculations will
  // allocate numbers on the heap. This could be alleviated by doing
  // intermediate calculations with raw wasm numbers, but it would add some
  // complexity.

  // After that, the first/second char can only be a decimal digit ('0'..'9').
  match (c) {
    0x30 => { // '0'
      // JSON doesn't allow numbers with additional leading zeros like
      // "01". Which means that if a number starts with zero then the
      // integer part is just zero and the next one can only be one of
      // '.', 'e' or 'E'. In any case all that needs to be done here is
      // to advance over the zero character and proceed to the optional
      // fractional and exponential parts. If another digit follows then
      // a parsing error will occur as expected, but implicitly because
      // this function finishes with the parser positioned on a digit
      // and not on a token expected after a number like ',', ']', '}' or
      // EOF.
      c = next(parserImplHelper)
    },
    x when x >= 0x31 && x <= 0x39 => { // '1'..'9'
      for (; ;) {
        let digit = c - 0x30

        significand = significand * 10 + digit

        c = next(parserImplHelper)

        if (c < 0x30 || c > 0x39) {
          break
        }
      }

      void
    },
    _ => {
      // The integer part of the number has to have at least one digit.
      // JSON doesn't allow numbers starting with decimal separator like ".1".
      err = Some(buildUnexpectedTokenError(parserImplHelper))
    }
  }

  // Optional fractional part of the number.
  if (Option.isNone(err) && c == 0x2E) { // '.'
    c = next(parserImplHelper)

    // let mut decimalPos = 10
    // let mut denominator = 1
    for (; c >= 0x30 && c <= 0x39; ) {
      let digit = c - 0x30

      significand = significand * 10 + digit

      // denominator = denominator * 10

      c = next(parserImplHelper)

      exponent = exponent - 1
    }
    // result /= denominator
  }

  // Optional exponential part of the number.
  if (Option.isNone(err) && (c == 0x65 || c == 0x45)) { // 'e' or 'E'
    c = next(parserImplHelper)

    // can start with optional plus or minus sign
    isExponentNegative = match(c) {
      0x2D => { // '-'
        c = next(parserImplHelper)
        true
      },
      0x2B => { // '+'
        c = next(parserImplHelper)
        false
      },
      _ => {
        false
      }
    }
    
    // folowed by one or more digits (0-9)

    let mut explicitExponent = 0
    for (; c >= 0x30 && c <= 0x39; ) {
      let digit = c - 0x30

      explicitExponent = explicitExponent * 10 + digit

      c = next(parserImplHelper)
    }

    if (isExponentNegative) {
      exponent = exponent - explicitExponent
    } else {
      exponent = exponent + explicitExponent
    }

    void
  }

  // Note that unlike all other JSON value types there's no explicit ending
  // character like ('"' for strings, ']' for arrays,'}' for objects etc). We
  // just leave the parser state at current position and the reading of next
  // token will succeed or fail, but number parsing just ends here.
  
  match(err) {
    Some(e) => Err(e),
    None => {
      let mut result = significand

      if (exponent != 0) {
        // This is just a temporary naive implementation.

        if (exponent > 0) {
          let mut factor = 1
          for (let mut i=0; i<exponent; i += 1) {
            factor = factor * 10
          }
          result = result * factor
        } else {
          let mut factor = 1
          for (let mut i=0; i<(0-exponent); i += 1) {
            factor = factor * 10
          }
          result = result / factor
        }
      }

      if (isNegative) {
        result = 0 - result
      }
      Ok(JSONNumber(result))
    }
  }
}
, parseArray = (parserImplHelper: JSONParserImplHelper) => {
  match (expectCodePointAndAdvance(0x5B, parserImplHelper)) { // '['
    Some(e) => Err(e),
    None => {
      let mut err = None

      let mut elems = [] : List<JSON>

      let mut done = false

      while (!done) {
        let c = parserImplHelper.currentCodePoint
        match (c) {
          0x2C => { // ','
            next(parserImplHelper)
            skipWhiteSpace(parserImplHelper)
          },
          0x5D => { // ']'
            next(parserImplHelper)
            done = true
            break
          },
          -1 => {
            // just end the loop without setting done to true
            break
          },
          _ => {
            // note that parseValue skips initial and final whitespace
            match (parseValue(parserImplHelper)) {
              Ok(elem) => {
                elems = [elem, ...elems]
                void
              },
              Err(e) => {
                err = Some(e)
                break
              }
            }
          },
        }
      }

      match(err) {
        Some(e) => Err(e),
        None => {
          if (done) {
            Ok(JSONArray(List.reverse(elems)))
          } else {
            Err(buildUnexpectedTokenError(parserImplHelper))
          }
        }
      }
    }
  }
}
, parseObject = (parserImplHelper: JSONParserImplHelper) => {
  match (expectCodePointAndAdvance(0x7B, parserImplHelper)) { // '{'
    Some(e) => Err(e),
    None => {
      let mut err = None

      let mut entries = [] : List<(String,JSON)>

      let mut done = false
      let mut first = true

      // one iteration of this loop should correspond to a key-value pair
      while (!done) {
        skipWhiteSpace(parserImplHelper)
        
        let c = parserImplHelper.currentCodePoint
        match (c) {
          -1 => {
            err = Some(UnexpectedEndOfInput)
            break
          },
          0x2C => { // ','
            if (first) {
              err = Some(buildUnexpectedTokenError(parserImplHelper))
              break
            } else {
              next(parserImplHelper)
              void
            }
          },
          0x7D => { // '}'
            next(parserImplHelper)
            done = true
            break
          },
          _ => {
            // A new entry in current object.
            // Just call parseString directly. In case the current character id not '"', it will return an error we can pass along.
            match (parseString(parserImplHelper)) {
              Ok(key) => {
                skipWhiteSpace(parserImplHelper)

                match (expectCodePointAndAdvance(0x3A, parserImplHelper)) { // ':'
                  None => {
                    // note that parseValue skips initial and final whitespace
                    match (parseValue(parserImplHelper)) {
                      Ok(value) => {
                        entries = [(key,value), ...entries]
                        first = false
                        void
                      },
                      Err(e) => {
                        err = Some(e)
                        break
                      }
                    }
                  },
                  Some(e) => {
                    err = Some(e)
                    break
                  }
                }
              },
              Err(e) => {
                err = Some(e)
                break
              }
            }
          },
        }
      } // end of entry loop

      match(err) {
        Some(e) => Err(e),
        None => {
          if (done) {
            Ok(JSONObject(List.reverse(entries)))
          } else {
            // This brand is not expected to actually execute, 
            // but in case it does, may just as well do the right thing.
            Err(buildUnexpectedTokenError(parserImplHelper))
          }
        }
      }
    }
  }
}

export let parse : String -> Result<JSON,Exception> = (str: String) => {
  let reader = StringReader.make(str)

  let parserImplHelper = {
    reader: reader,
    currentCodePoint: StringReader.readCodePointFast(reader),
    pos: 0
  }: JSONParserImplHelper

  let root = parseValue(parserImplHelper)

  skipWhiteSpace(parserImplHelper)

  if (isAtEndOfInput(parserImplHelper)) {
    root
  } else {
    match (root) {
      Ok(_) => Err(buildUnexpectedTokenError(parserImplHelper)),
      e => e
    }
  }
}
