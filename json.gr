import List from "list"
import Float64 from "float64"
import { int32ToHex, unicodeCodepointToSurrogatePair } from "stubs"
import String from "string"
import Char from "char"
import Array from "array"
import Int32 from "int32"
import Bytes from "bytes"
import StringBuilder from "stringbuilder"

export enum JSON {
	JSONNull,
	JSONBoolean(Bool),
	JSONNumber(Float64),
	JSONString(String),
	// Here I've chosen to use a List and not an array as a conscious trad of performance for immutability.
	// I'd love to use a more advanced persistent collection instead, but there currently aren't any in Grain.
	JSONArray(List<JSON>),
	// Note that JSONObject here is deliberately defined as a simple list of key value pair tuples as opposed
	// to for example a Map in order to accomodate the fact that the ECMA-404 standard doesn't prohibit
	// duplicate names in Objects. Such JSON should be representable by the JSON data structure for lossless
	// processing. This also vastly simplifies implementation and has the benefit of List's immutability.
	JSONObject(List<(String,JSON)>)
}

export enum IndentationFormat {
	NoIndentation,
	IndentWithTab,
	IndentWithSpaces(Number)
}

export enum ArrayFormat {
	CompactArrayEntries,
	OneArrayEntryPerLine
}

export enum ObjectFormat {
	CompactObjectEntries,
	OneObjectEntryPerLine
}

export enum LineEnding {
	NoLineEnding,
	LineFeed,
	CarriageReturnLineFeed,
	CarriageReturn
}

export record FormattingSettings {
	indentation: IndentationFormat,
	arrayFormat: ArrayFormat,
	objectFormat: ObjectFormat,
	lineEnding: LineEnding,
	finishWithNewLine: Bool,
	escapeAllControlPoints: Bool,
	escapeHTMLUnsafeSequences: Bool,
	escapeNonASCII: Bool
}

// Compact formatting that minimizes the size of resulting JSON at cost of not being easily human readable.
// Only performs minimal string escaping as required by the ECMA-404 standard, so the result needs to
// be treated as proper unicode and is not safe to be transported in ASCII encoding.
export let defaultCompactFormat =
	() => {
		indentation: NoIndentation,
		arrayFormat: CompactArrayEntries,
		objectFormat: CompactObjectEntries,
		lineEnding: NoLineEnding,
		finishWithNewLine: false,
		escapeAllControlPoints: false,
		escapeHTMLUnsafeSequences: false,
		escapeNonASCII: false
	} : FormattingSettings

// Recommended human readable formatting.
// Escapes all control points for the sake of clarity, but doesn't go the extra mile to escape additional
// sequences or unicode characters.
export let defaultPrettyFormat =
	() => {
		indentation: IndentWithSpaces(2),
		arrayFormat: OneArrayEntryPerLine,
		objectFormat: OneObjectEntryPerLine,
		lineEnding: LineFeed,
		finishWithNewLine: true,
		escapeAllControlPoints: true,
		escapeHTMLUnsafeSequences: false,
		escapeNonASCII: false
	} : FormattingSettings

// Compact and conservative formatting to maximize compatibility and embeddability of the resulting JSON.
// Should be safe to copy and paste directly into HTML and to transported in plain ASCII.
export let defaultCompactAndSafeFormat =
	() => {
		indentation: NoIndentation,
		arrayFormat: CompactArrayEntries,
		objectFormat: CompactObjectEntries,
		lineEnding: NoLineEnding,
		finishWithNewLine: false,
		escapeAllControlPoints: true,
		escapeHTMLUnsafeSequences: true,
		escapeNonASCII: true
	} : FormattingSettings

// Pretty and conservative formatting to maximize compatibility and embeddability of the resulting JSON.
// Should be safe to copy and paste directly into HTML and to transported in plain ASCII.
export let defaultPrettyAndSafeFormat =
	() => {
		indentation: IndentWithSpaces(2),
		arrayFormat: OneArrayEntryPerLine,
		objectFormat: OneObjectEntryPerLine,
		lineEnding: LineFeed,
		finishWithNewLine: true,
		escapeAllControlPoints: true,
		escapeHTMLUnsafeSequences: true,
		escapeNonASCII: true
	} : FormattingSettings

let printIndentation = (indentation: IndentationFormat, emit, indentationLevel: Number) => {
	match (indentation) {
		IndentWithTab => {
			let mut count = 0
			while (count < indentationLevel) {
				emit("\u0009")
				count += 1;
			}
		},
		IndentWithSpaces(spacesPerIndentation) => {
			let mut count = 0
			while (count < indentationLevel*spacesPerIndentation) {
				emit("\u0020")
				count += 1;
			}
		},
		NoIndentation => void
	}
}

let emitUTF16EscapeSequence = (codePoint: Int32, emit) => {
	// if (codePoint < 0n || codePoint > 0xFFFFn)
	// 	throw InvalidArgument("emitUTF16EscapeSequence() codePoint must be between 0 and 0xFFFF")

	emit("\\u");
	let hex = int32ToHex(codePoint)
	let mut len = String.length(hex)
	while (len < 4) {
		emit("0")
		len += 1;
	}
	emit(hex);
}

let emitEscapedUnicodeSequence = (codePoint: Number, emit) => {
	// See the String section in the ECMA-404 doc.
	// If the code point is "in the Basic Multilingual Plane", that is
	// in range 0..65535. Greater values need to be split into two
	// UTF-16 chunks.
	let i = Int32.fromNumber(codePoint);
	if (codePoint <= 0xFFFF) {
		emitUTF16EscapeSequence(i, emit)
	} else {
		let (lowSurrogate, highSurrogate) = unicodeCodepointToSurrogatePair(codePoint)
		emitUTF16EscapeSequence(Int32.fromNumber(highSurrogate), emit)
		emitUTF16EscapeSequence(Int32.fromNumber(lowSurrogate), emit)
	}
}

let lineEndingToString = (lineEnding: LineEnding) => {
	match (lineEnding) {
		NoLineEnding => "",
		LineFeed => "\n",
		CarriageReturnLineFeed => "\r\n",
		CarriageReturn => "\r"
	}
}

// Escapes the provided string and emits the result char by char with the emit function.
let emitEscapedString = (s: String, format: FormattingSettings, emit) => {
	// Escape the string.
	// Probably a good candidate for low level optimization.
	// Mostly to avoid allocating the char array.
	// Also doesn't grain allow matching on numbers?
	let chars = String.explode(s)
	let mut i = 0
	let len = Array.length(chars)
	let mut prevChar = '\u0000';
	let mut char = '\u0000';
	while (i < len) {
		char = chars[i];

		match (char) {
			'\u0008' => emit("\\b"), // backspace
			'\u0009' => emit("\\t"), // tab
			'\u000A' => emit("\\n"), // line feed
			'\u000C' => emit("\\f"), // form feed
			'\u000D' => emit("\\r"), // carriage return
			'\u0022' => emit("\\\""), // quotation mark
			'\u005C' => emit("\\\\"), // backslash or "Reverse Solidus"
			//c => emit(toString(c))
			c => {
				let codePoint = Char.code(char);

				/*
				if (codePoint == 8) { // backspace
					emit("\\b")
				} else if (codePoint == 9) { // tab
					emit("\\t")
				} else if (codePoint == 10) { // line feed
					emit("\\n")
				} else if (codePoint == 12) { // form feed
					emit("\\f")
				} else if (codePoint == 13) { // carriage return
					emit("\\r")
				} else if (codePoint == 34) { // quotation mark
					emit("\\\"")
				} else if (codePoint == 92) { // backspace
					emit("\\\\")
				}
				*/
				
				if (codePoint >= 0 && codePoint <= 31) {
					// ASCII or "C0" control point group, except 127, handled separately.
					// The ECMA-404 spec only requires to escape the control point codes 0-31,
					// But it may be desirable to escape other control points or even everything
					// other than printable ASCII characters for compatiblity, easier transport,
					// embedding etc. Thus I've decided to expose options for this, but otherwise
					// just a sane default would suffice.
					emitEscapedUnicodeSequence(codePoint, emit)
				} else if (codePoint >= 127 && codePoint <= 159 && format.escapeAllControlPoints) {
					// ASCII control point 127 and unicode control point group C1 (128-159)
					emitEscapedUnicodeSequence(codePoint, emit)

					// There could be more control points or otherwise escape worthy codepoints,
					// but covering that would be overkill. For everything outside of the ASCII
					// range the user has to decide whether to escape all unicode codepoint or
					// nothing, including the .
				} else if (codePoint >= 128 && format.escapeNonASCII) {
					// If the user chooses to do so, escape all non ASCII code points.
					emitEscapedUnicodeSequence(codePoint, emit)
				} else if (char == '/' && format.escapeHTMLUnsafeSequences) {
					// Additionally many JSON libraries escape additional two character sequences for
					// direct embedding into html for example. This is specifically to avoid emitting
					// the sequence "</" like in "</script>".
					// The lazy approach would be to just escape the slash (which can become "\\/",
					// not necessarily "\u002F"). This more conservative approach only escapes it
					// when needed.
					if (prevChar == '<') {
						emit("\\/")
					} else {
						// otherwise just emit the slash as-is
						emit("/")
					}
				} else {
					emit(toString(char))
				}
			}
		}

		i += 1;
		prevChar = char;
	}
}

let emitEscapedQuotedString = (s: String, format: FormattingSettings, emit) => {
	emit("\"")
	emitEscapedString(s, format, emit)
	emit("\"")
}

// FIXME can't define explicit type for the emit parameter
// or am I doing something wrong?
let rec emitJSONElement = (json: JSON, format: FormattingSettings, lineEnding: String, emit, indentationLevel: Number) => {
	match (json) {
		JSONNull => emit("null"),

		// FIXME why does it sometimes require other times not? Seemingly at random.
		// JSONBoolean(true) => emit("true"),
		// JSONBoolean(false) => emit("false"),
		
		JSONBoolean(b) => emit(if (b) "true" else "false"),

		// FIXME is Grain's printing of bools and numbers always compatible with JSON?
		// Probably, but we probably want to customize a bit.
		// For example to print natural numberso without ".0" for compactness sake.
		// Maybe customizable? Node does it.
		// FIXME does grain allow Inf and NaN?
		// These are not supported JSON values.
		// What to do with them?
		JSONNumber(n) => emit(toString(n)),

		JSONString(s) => emitEscapedQuotedString(s, format, emit),

		JSONArray(elems) => {
			match (format.arrayFormat) {
				CompactArrayEntries => {
					emit("[")
					// FIXME doest it always allocate the lambda?
					List.forEachi(
						(e, i) => {
							if (i > 0)
								emit(",")
							emitJSONElement(e, format, lineEnding, emit, indentationLevel+1)
						},
						elems
					)
					emit("]")
				},
				OneArrayEntryPerLine => {
					match (elems) {
						[] => {
							emit("[]")
						},
						[e] => {
							emit("[ ")
							emitJSONElement(e, format, lineEnding, emit, indentationLevel+1)
							emit(" ]")
						},
						elems => {
							emit("[")
							emit(lineEnding)
							List.forEachi(
								(e, i) => {
									if (i > 0) {
										emit(",")
										emit(lineEnding)
									}
									printIndentation(format.indentation, emit, indentationLevel+1)
									
									emitJSONElement(e, format, lineEnding, emit, indentationLevel+1)
								},
								elems
							)
							emit(lineEnding)
							printIndentation(format.indentation, emit, indentationLevel)
							emit("]")
						}
					}
				}
			}
		},

		JSONObject(entries) => {
			match (format.objectFormat) {
				CompactObjectEntries => {
					emit("{")
					List.forEachi(
						((key, value), i) => {
							if (i > 0)
								emit(",")

							emitEscapedQuotedString(key, format, emit)
							emit(":")
							emitJSONElement(value, format, lineEnding, emit, indentationLevel+1)
						},
						entries
					)
					emit("}")
				},
				OneObjectEntryPerLine => {
					match (entries) {
						[] => {
							emit("{}")
						},
						[(key, value)] => {
							emit("{ ")
							emitEscapedQuotedString(key, format, emit)
							emit(": ")
							emitJSONElement(value, format, lineEnding, emit, indentationLevel+1)
							emit(" }")
						},
						entries => {
							emit("{")
							emit(lineEnding)
							List.forEachi(
								((key, value), i) => {
									if (i > 0) {
										emit(",")
										emit(lineEnding)
									}
									printIndentation(format.indentation, emit, indentationLevel+1)
									
									emitEscapedQuotedString(key, format, emit)
									emit(": ")
									emitJSONElement(value, format, lineEnding, emit, indentationLevel+1)
								},
								entries
							)
							emit(lineEnding)
							printIndentation(format.indentation, emit, indentationLevel)
							emit("}")
						}
					}
				}
			}
		}
	}
}

let rec emitJSON = (json: JSON, format: FormattingSettings, emit) => {
	let lineEnding = lineEndingToString(format.lineEnding)

	emitJSONElement(json, format, lineEnding, emit, 0)

	if (format.finishWithNewLine)
		emit(lineEnding)
}

export let toString = (json: JSON, format: FormattingSettings) => {
	// If we want to be smart about limiting allocations it may make sense to
	// guesstimate the capacity by traversing the json .
	let buf = StringBuilder.make(1)
	emitJSON(json, format, (s) => {
		StringBuilder.append(s, buf)
	})
	StringBuilder.toString(buf)
}

export let toStringCompact = (json: JSON) => toString(json, defaultCompactFormat())

export let toStringPretty = (json: JSON) => toString(json, defaultPrettyFormat())
