import {
	getUnicodeCodepointUTF16LowSurrogate,
	getUnicodeCodepointUTF16HighSurrogate,
	isFinite,
	isNaN
} from "stubs"
import String from "string"
import Char from "char"
import Array from "array"
import StringBuilder from "stringbuilder"
import Option from "option"
import NumberUtils from "runtime/numberUtils"
import Numbers from "runtime/numbers"
import Memory from "runtime/unsafe/memory"
import WasmI32 from "runtime/unsafe/wasmi32"

export enum JSON {
	JSONNull,
	JSONBoolean(Bool),
	JSONNumber(Number),
	JSONString(String),
	// Here I've chosen to use a List and not an array as a conscious trad of performance for immutability.
	// I'd love to use a more advanced persistent collection instead, but there currently aren't any in Grain.
	JSONArray(List<JSON>),
	// Note that JSONObject here is deliberately defined as a simple list of key value pair tuples as opposed
	// to for example a Map in order to accomodate the fact that the ECMA-404 standard doesn't prohibit
	// duplicate names in Objects. Such JSON should be representable by the JSON data structure for lossless
	// processing. This also vastly simplifies implementation and has the benefit of List's immutability.
	JSONObject(List<(String,JSON)>)
}

export enum IndentationFormat {
	NoIndentation,
	IndentWithTab,
	IndentWithSpaces(Number)
}

export enum ArrayFormat {
	CompactArrayEntries,
	OneArrayEntryPerLine
}

export enum ObjectFormat {
	CompactObjectEntries,
	OneObjectEntryPerLine
}

export enum LineEnding {
	NoLineEnding,
	LineFeed,
	CarriageReturnLineFeed,
	CarriageReturn
}

export record FormattingSettings {
	indentation: IndentationFormat,
	arrayFormat: ArrayFormat,
	objectFormat: ObjectFormat,
	lineEnding: LineEnding,
	finishWithNewLine: Bool,
	escapeAllControlPoints: Bool,
	escapeHTMLUnsafeSequences: Bool,
	escapeNonASCII: Bool
}

// Compact formatting that minimizes the size of resulting JSON at cost of not being easily human readable.
// Only performs minimal string escaping as required by the ECMA-404 standard, so the result needs to
// be treated as proper unicode and is not safe to be transported in ASCII encoding.
export let defaultCompactFormat =
	() => {
		indentation: NoIndentation,
		arrayFormat: CompactArrayEntries,
		objectFormat: CompactObjectEntries,
		lineEnding: NoLineEnding,
		finishWithNewLine: false,
		escapeAllControlPoints: false,
		escapeHTMLUnsafeSequences: false,
		escapeNonASCII: false
	} : FormattingSettings

// Recommended human readable formatting.
// Escapes all control points for the sake of clarity, but doesn't go the extra mile to escape additional
// sequences or unicode characters.
export let defaultPrettyFormat =
	() => {
		indentation: IndentWithSpaces(2),
		arrayFormat: OneArrayEntryPerLine,
		objectFormat: OneObjectEntryPerLine,
		lineEnding: LineFeed,
		finishWithNewLine: true,
		escapeAllControlPoints: true,
		escapeHTMLUnsafeSequences: false,
		escapeNonASCII: false
	} : FormattingSettings

// Compact and conservative formatting to maximize compatibility and embeddability of the resulting JSON.
// Should be safe to copy and paste directly into HTML and to transported in plain ASCII.
export let defaultCompactAndSafeFormat =
	() => {
		indentation: NoIndentation,
		arrayFormat: CompactArrayEntries,
		objectFormat: CompactObjectEntries,
		lineEnding: NoLineEnding,
		finishWithNewLine: false,
		escapeAllControlPoints: true,
		escapeHTMLUnsafeSequences: true,
		escapeNonASCII: true
	} : FormattingSettings

// Pretty and conservative formatting to maximize compatibility and embeddability of the resulting JSON.
// Should be safe to copy and paste directly into HTML and to transported in plain ASCII.
export let defaultPrettyAndSafeFormat =
	() => {
		indentation: IndentWithSpaces(2),
		arrayFormat: OneArrayEntryPerLine,
		objectFormat: OneObjectEntryPerLine,
		lineEnding: LineFeed,
		finishWithNewLine: true,
		escapeAllControlPoints: true,
		escapeHTMLUnsafeSequences: true,
		escapeNonASCII: true
	} : FormattingSettings

record Writer {
	write: String -> Void,
	writeChar: Char -> Void,
	writeUnicodeCodePoint: Number -> Void,
	writeNewLine: () -> Void
}

let printIndentation = (indentation: IndentationFormat, writer: Writer, indentationLevel: Number) => {
	match (indentation) {
		IndentWithTab => {
			let mut count = 0
			while (count < indentationLevel) {
				writer.writeChar('\t')
				count += 1;
			}
		},
		IndentWithSpaces(spacesPerIndentation) => {
			let mut count = 0
			while (count < indentationLevel*spacesPerIndentation) {
				writer.writeChar(' ')
				count += 1;
			}
		},
		NoIndentation => void
	}
}

@disableGC
let emitUTF16EscapeSequence = (codePoint: Number, writer: Writer) => {
	// if (codePoint < 0n || codePoint > 0xFFFFn)
	// 	throw InvalidArgument("emitUTF16EscapeSequence() codePoint must be between 0 and 0xFFFF")

	writer.write("\\u");

	// If we want to absolutely avoid allocations for the hex sequence then
	// could fork the itoa32 function, but seems a bit of an overkill and
	// would blow up library size with duplicate code.
	let asWasmI32 = Numbers.coerceNumberToWasmI32(codePoint)
	let hex = NumberUtils.itoa32(asWasmI32, 16n)
	
	let mut len = String.length(hex)
	while (len < 4) {
		writer.writeChar('0')
		len += 1;
	}
	writer.write(hex);

	Memory.free(WasmI32.fromGrain(hex))
}

let emitEscapedUnicodeSequence = (codePoint: Number, writer: Writer) => {
	// See the String section in the ECMA-404 doc.
	// If the code point is "in the Basic Multilingual Plane", that is
	// in range 0..65535. Greater values need to be split into two
	// UTF-16 chunks.
	if (codePoint <= 0xFFFF) {
		emitUTF16EscapeSequence(codePoint, writer)
	} else {
		let highSurrogate = getUnicodeCodepointUTF16HighSurrogate(codePoint)
		let lowSurrogate = getUnicodeCodepointUTF16LowSurrogate(codePoint)
		emitUTF16EscapeSequence(highSurrogate, writer)
		emitUTF16EscapeSequence(lowSurrogate, writer)
	}
}

// Escapes the provided string and emits the result char by char with the emit function.
let emitEscapedString = (s: String, format: FormattingSettings, writer: Writer) => {
	// Escape the string.
	// Probably a good candidate for low level optimization.
	// Mostly to avoid allocating the char array.
	// Also doesn't grain allow matching on numbers?
	let chars = String.explode(s)
	let mut i = 0
	let len = Array.length(chars)
	let mut prevChar = '\u0000';
	let mut char = '\u0000';
	while (i < len) {
		char = chars[i];

		match (char) {
			'\u0008' => writer.write("\\b"), // backspace
			'\u0009' => writer.write("\\t"), // tab
			'\u000A' => writer.write("\\n"), // line feed
			'\u000C' => writer.write("\\f"), // form feed
			'\u000D' => writer.write("\\r"), // carriage return
			'\u0022' => writer.write("\\\""), // quotation mark
			'\u005C' => writer.write("\\\\"), // backslash or "Reverse Solidus"
			//c => emit(toString(c))
			c => {
				let codePoint = Char.code(char);

				/*
				if (codePoint == 8) { // backspace
					emit("\\b")
				} else if (codePoint == 9) { // tab
					emit("\\t")
				} else if (codePoint == 10) { // line feed
					emit("\\n")
				} else if (codePoint == 12) { // form feed
					emit("\\f")
				} else if (codePoint == 13) { // carriage return
					emit("\\r")
				} else if (codePoint == 34) { // quotation mark
					emit("\\\"")
				} else if (codePoint == 92) { // backspace
					emit("\\\\")
				}
				*/
				
				if (codePoint >= 0 && codePoint <= 31) {
					// ASCII or "C0" control point group, except 127, handled separately.
					// The ECMA-404 spec only requires to escape the control point codes 0-31,
					// But it may be desirable to escape other control points or even everything
					// other than printable ASCII characters for compatiblity, easier transport,
					// embedding etc. Thus I've decided to expose options for this, but otherwise
					// just a sane default would suffice.
					emitEscapedUnicodeSequence(codePoint, writer)
				} else if (codePoint >= 127 && codePoint <= 159 && format.escapeAllControlPoints) {
					// ASCII control point 127 and unicode control point group C1 (128-159)
					emitEscapedUnicodeSequence(codePoint, writer)

					// There could be more control points or otherwise escape worthy codepoints,
					// but covering that would be overkill. For everything outside of the ASCII
					// range the user has to decide whether to escape all unicode codepoint or
					// nothing, including the .
				} else if (codePoint >= 128 && format.escapeNonASCII) {
					// If the user chooses to do so, escape all non ASCII code points.
					emitEscapedUnicodeSequence(codePoint, writer)
				} else if (char == '/' && format.escapeHTMLUnsafeSequences) {
					// Additionally many JSON libraries escape additional two character sequences for
					// direct embedding into html for example. This is specifically to avoid emitting
					// the sequence "</" like in "</script>".
					// The lazy approach would be to just escape the slash (which can become "\\/",
					// not necessarily "\u002F"). This more conservative approach only escapes it
					// when needed.
					if (prevChar == '<') {
						writer.write("\\/")
					} else {
						// otherwise just emit the slash as-is
						writer.writeChar('/')
					}
				} else {
					writer.writeUnicodeCodePoint(codePoint)
				}
			}
		}

		i += 1;
		prevChar = char;
	}
}

let emitEscapedQuotedString = (s: String, format: FormattingSettings, writer: Writer) => {
	writer.write("\"")
	emitEscapedString(s, format, writer)
	writer.write("\"")
}

export exception InvalidJSON(String)

// FIXME can't define explicit type for the emit parameter
// or am I doing something wrong?
let rec emitJSONElement = (json: JSON, format: FormattingSettings, writer: Writer, indentationLevel: Number) => {
	let mut err = None : Option<Exception>;

	match (json) {
		JSONNull => writer.write("null"),

		JSONBoolean(b) => writer.write(if (b) "true" else "false"),

		JSONNumber(n) => {
			if (isFinite(n)) {
				// In order to not duplicate code here I simply use Grain's
				// toString of Number. This is a bit risky because as far as I
				// can tell what it outputs is not formally documented. So
				// any changes to that could result in invalid JSON here. For
				// now at least it was considered the way to go. If one day a
				// decision is made to fork that function. The starting point
				// would be NumberUtils.dtoa and some optimizations could
				// probably be done like avoiding memory allocations or
				// checking for NaNs/Infs two times.
				writer.write(toString(n))
			} else {
				// JSON standard doesn't allow NaN or infinite values in numbers,
				// but WASM f64 (IEEE 754-2008), as well as Grain's number types do
				// (Float64 as well as Number). This is the only reason that the
				// formatting needs to return a Result and not just a String
				// directly. Other possible choices were to throw exceptions or to
				// coninue formatting without representing these values correctly
				// (like JavaScript's JSON.stringify).
				if (isNaN(n)) {
					err = Some(InvalidJSON("NaN is not allowed in JSONNumber"))
				} else if (n < 0) {
					err = Some(InvalidJSON("-Infinity is not allowed in JSONNumber"))
				} else {
					err = Some(InvalidJSON("Infinity is not allowed in JSONNumber"))
				}
			}
		},

		JSONString(s) => emitEscapedQuotedString(s, format, writer),

		JSONArray(elems) => {
			// Here I'm not using List.forEachi or similar in order to avoid allocations of closures.
			// The code is verbose and a bit ugly as a consequence, but I think it's an OK price for
			// [presumed] performance gain. Another approach would be to allocate a function for
			// formattng arrays just once at the start of formatting and pass it in emitJSONElement.
			
			match (elems) {
				[] => writer.write("[]"),
				[e] => {
					writer.write("[")
					if (format.arrayFormat == OneArrayEntryPerLine)
						writer.writeNewLine()
					
					if (format.arrayFormat == OneArrayEntryPerLine)
						printIndentation(format.indentation, writer, indentationLevel+1)
					
					err = emitJSONElement(e, format, writer, indentationLevel+1)

					if (Option.isNone(err)) {
						if (format.arrayFormat == OneArrayEntryPerLine) {
							writer.writeNewLine()
							printIndentation(format.indentation, writer, indentationLevel)
						}
						writer.write("]")
					}
				},
				[initialHead, ...initialRest] => {
					writer.write("[")
					if (format.arrayFormat == OneArrayEntryPerLine)
						writer.writeNewLine()

					let mut currentHead = initialHead
					let mut currentRest = initialRest

					for (let mut index = 0; ; index += 1) {
						if (index > 0) {
							writer.write(",")
							if (format.arrayFormat == OneArrayEntryPerLine)
								writer.writeNewLine()
						}

						if (format.arrayFormat == OneArrayEntryPerLine)
							printIndentation(format.indentation, writer, indentationLevel+1)
						
						let elementError = emitJSONElement(currentHead, format, writer, indentationLevel+1)
						match(elementError) {
							None => void,
							Some(e) => {
								err = elementError
								break
							}
						}

						match (currentRest) {
							[] => break,
							[newHead, ...newRest] => {
								currentHead = newHead
								currentRest = newRest
							}
						}
					}

					if (Option.isNone(err)) {
						if (format.arrayFormat == OneArrayEntryPerLine) {
							writer.writeNewLine()
							printIndentation(format.indentation, writer, indentationLevel)
						}
						writer.write("]")
					}
				}
			}
		},

		JSONObject(entries) => {
			match (entries) {
				[] => writer.write("{}"),
				[(key, value)] => {
					writer.writeChar('{')
					if (format.objectFormat == OneObjectEntryPerLine) {
						writer.writeNewLine()
						printIndentation(format.indentation, writer, indentationLevel+1)
					}
					
					emitEscapedQuotedString(key, format, writer)
					writer.write(
						match (format.objectFormat) {
							CompactObjectEntries => ":",
							OneObjectEntryPerLine => ": "
						}
					)
					err = emitJSONElement(value, format, writer, indentationLevel+1)

					if (Option.isNone(err)) {
						if (format.objectFormat == OneObjectEntryPerLine) {
							writer.writeNewLine()
							printIndentation(format.indentation, writer, indentationLevel)
						}
						writer.writeChar('}')
					}
				},
				[initialHead, ...initialRest] => {
					writer.writeChar('{')
					if (format.objectFormat == OneObjectEntryPerLine)
						writer.writeNewLine()

					let mut currentHead = initialHead
					let mut currentRest = initialRest

					for (let mut index = 0; ; index += 1) {
						if (index > 0) {
							writer.write(",")
							if (format.objectFormat == OneObjectEntryPerLine)
								writer.writeNewLine()
						}

						if (format.objectFormat == OneObjectEntryPerLine)
							printIndentation(format.indentation, writer, indentationLevel+1)

						let (key, value) = currentHead
						
						emitEscapedQuotedString(key, format, writer)
						writer.write(
							match (format.objectFormat) {
								CompactObjectEntries => ":",
								OneObjectEntryPerLine => ": "
							}
						)
						let elementError = emitJSONElement(value, format, writer, indentationLevel+1)
						match(elementError) {
							None => void,
							Some(e) => {
								err = elementError
								break
							}
						}

						match (currentRest) {
							[] => break,
							[newHead, ...newRest] => {
								currentHead = newHead
								currentRest = newRest
							}
						}
					}

					if (Option.isNone(err)) {
						if (format.objectFormat == OneObjectEntryPerLine) {
							writer.writeNewLine()
							printIndentation(format.indentation, writer, indentationLevel)
						}
						writer.writeChar('}')
					}
				}
			}
		}
	}

	err
}

let emitJSON = (json: JSON, format: FormattingSettings, writer: Writer) => {
	let error = emitJSONElement(json, format, writer, 0)

	if (format.finishWithNewLine && Option.isNone(error))
		writer.writeNewLine()

	error
}

let makeWriter = (buf: StringBuilder.StringBuilder, lineEnding: LineEnding) => {
	{
		write: s => StringBuilder.append(s, buf),
		writeChar: c => StringBuilder.appendChar(c, buf),
		writeUnicodeCodePoint: c => StringBuilder.appendUnicodeCodePoint(c, buf),
		writeNewLine: match (lineEnding) {
			NoLineEnding => () => void,
			LineFeed => () => StringBuilder.appendChar('\n', buf),
			CarriageReturnLineFeed => () => StringBuilder.append("\r\n", buf),
			CarriageReturn => () => StringBuilder.appendChar('\r', buf),
		},
	} : Writer
}

export let toString = (json: JSON, format: FormattingSettings) => {
	// If we want to be smart about limiting allocations it may make sense to
	// guesstimate the capacity by traversing the json .
	let buf = StringBuilder.make(16)

	let writer = makeWriter(buf, format.lineEnding)

	let error = emitJSON(json, format, writer)

	match (error) {
		None => Ok(StringBuilder.toString(buf)),
		Some(e) => Err(e)
	}
}

export let toStringCompact = (json: JSON) => toString(json, defaultCompactFormat())

export let toStringPretty = (json: JSON) => toString(json, defaultPrettyFormat())
