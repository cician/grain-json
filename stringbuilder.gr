import Exception from "runtime/exception"
import Bytes from "bytes"
import String from "string"
import WasmI32 from "runtime/unsafe/wasmi32"
import Memory from "runtime/unsafe/memory"
import { coerceNumberToWasmI32 } from "runtime/numbers"
import { tagSimpleNumber } from "runtime/dataStructures"

export record StringBuilder {
	mut size: Number,
	mut capacity: Number,
	growthFunction: (Number, Number) -> Number,
	mut buffer: Bytes
}

let defaultGrowthFunction = (currentCapacity: Number, newRequiredCapacity: Number) => {
	// The idea is to grow the size exponentially to quickly adapt in situations with
	// many small writes, but only up to a certain point because after that the risk
	// is to saturate overall available memory. After that .
	// In a WASM64 context different decisions can be made.
	// Maybe could use actual available memory for this decison?

	if (currentCapacity < 104857600) { // arbitrary limit of 100MiB
		currentCapacity + currentCapacity * 2
	} else {
		currentCapacity + 1048576 // arbitrary increment of 1MiB
	}
}

export let makeWithGrowthFunction = (initialCapacity: Number, growthFunction: (Number, Number) -> Number) => {
	if (initialCapacity <= 0)
		throw Exception.InvalidArgument("initialCapacity must be a positive natural number")

	{
		size: 0,
		capacity: initialCapacity,
		growthFunction: growthFunction,
		buffer: Bytes.make(initialCapacity)
	}: StringBuilder
}

export let make = (initialCapacity: Number) => makeWithGrowthFunction(initialCapacity, defaultGrowthFunction);

let _STRING_SIZE_OFFSET = 4n
let _STRING_VALUE_OFFSET = 8n
let _BYTES_SIZE_OFFSET = 4n;
let _BYTES_VALUE_OFFSET = 8n
let _CHAR_VALUE_OFFSET = 4n

@disableGC
let ensureCapacity = (newSize: WasmI32, builder: StringBuilder) => {
	let (+) = WasmI32.add
	let (<) = WasmI32.ltS
	let (>) = WasmI32.gtS
	let (>=) = WasmI32.geS
	let (*) = WasmI32.mul

	let currentSizeGrain = builder.size
	let currentSize = coerceNumberToWasmI32(currentSizeGrain)
	let currentCapacityGrain = builder.capacity
	let currentCapacity = coerceNumberToWasmI32(currentCapacityGrain)

	if (currentCapacity < newSize) {
		let growthFunction = builder.growthFunction

		// Note that coerceNumberToWasmI32 throws in case of signed 32 bit
		// number overflow. The maximum buffer size is constrained by this
		// anyway, but it means a comprehensible error for the user. So we may
		// want an explicit check maybe?
		let newGrowthCapacity = coerceNumberToWasmI32(growthFunction(currentCapacityGrain, tagSimpleNumber(newSize)))

		let newCapacity =
			if (newGrowthCapacity >= newSize && newGrowthCapacity > 0n) {
				newGrowthCapacity
			} else {
				newSize
			}

		if (newCapacity > currentCapacity) {
			let newCapacityGrain = tagSimpleNumber(newCapacity)

			let oldBuffer = builder.buffer
			let newBuffer = Bytes.make(newCapacityGrain)
			
			Bytes.move(0, 0, currentSizeGrain, oldBuffer, newBuffer)
			
			builder.capacity = newCapacityGrain
			builder.buffer = newBuffer

			ignore(Memory.decRef(WasmI32.fromGrain(oldBuffer)))
		}
	}
}

@disableGC
export let append = (s: String, builder: StringBuilder) => {
	let (+) = WasmI32.add

	let strPtr = WasmI32.fromGrain(s)

	let bytesToWrite = WasmI32.load(strPtr, _BYTES_SIZE_OFFSET) // Equivalent to String.byteLength(s), or just getSize if in Bytes module

	let currentGrain = builder.size
	let currentSize = coerceNumberToWasmI32(currentGrain)

	let newSize = currentSize + bytesToWrite

	// resize if necessary
	ensureCapacity(newSize, builder)

	// Copy the string's content into the buffer, offset by current size.
	String.encodeAt(s, String.UTF8, builder.buffer, currentGrain)

	builder.size = tagSimpleNumber(newSize)
}

@disableGC
export let appendChar = (c: Char, builder: StringBuilder) => {
	// This is based on Char.toString()
	let (&) = WasmI32.and
	let (==) = WasmI32.eq
	let (+) = WasmI32.add

	let currentSize = coerceNumberToWasmI32(builder.size)

	let charPtr = WasmI32.fromGrain(c)
	let byte = WasmI32.load8U(charPtr, 4n)
	
	if ((byte & 0x80n) == 0x00n) {
		let newSize = currentSize + 1n
		
		ensureCapacity(newSize, builder)

		let dstPtr = WasmI32.fromGrain(builder.buffer) + _BYTES_VALUE_OFFSET + currentSize

		// In this case the byte has already been read. So just write it into the buffer!
		WasmI32.store8(dstPtr, byte, 0n)
		
		builder.size = tagSimpleNumber(newSize)
	} else {
		let numBytes =
			if ((byte & 0xF0n) == 0xF0n) {
				4n
			} else if ((byte & 0xE0n) == 0xE0n) {
				3n
			} else {
				2n
			}

		let newSize = currentSize + numBytes

		ensureCapacity(newSize, builder)

		let dstPtr = WasmI32.fromGrain(builder.buffer) + _BYTES_VALUE_OFFSET + currentSize

		let srcPtr = WasmI32.fromGrain(c) + _CHAR_VALUE_OFFSET

		Memory.copy(dstPtr, srcPtr, numBytes)

		builder.size = tagSimpleNumber(newSize)
	}
}

@disableGC
export let appendUnicodeCodePoint = (codePoint: Number, builder: StringBuilder) => {
	// The code in function for actual encoding of the codepoint to bytes is
	// based on one from grain's stdlib String module called
	// writeUtf8CodePoint. Currently it's is not exposted, but perhaps more
	// importantly, embedding this code enables some optimizations and to know
	// the number of bytes for the code point without computing it twice.

	let (>>>) = WasmI32.shrU
	let (-) = WasmI32.sub
	let (&) = WasmI32.and
	let (|) = WasmI32.or
	let (+) = WasmI32.add
	let (<) = WasmI32.ltU
	let (<=) = WasmI32.leU
	let (==) = WasmI32.eq

	let codePoint = coerceNumberToWasmI32(codePoint)

	let currentSize = coerceNumberToWasmI32(builder.size)

	if (codePoint < 0n) {
		throw InvalidArgument("Invalid character code")
	}
	
	if (codePoint <= 0x007Fn) {
		let newSize = currentSize + 1n
		
		ensureCapacity(newSize, builder)

		let dstPtr = WasmI32.fromGrain(builder.buffer) + _BYTES_VALUE_OFFSET + currentSize

		WasmI32.store8(dstPtr, codePoint, 0n)
		
		builder.size = tagSimpleNumber(newSize)
	} else if (codePoint <= 0x07FFn) {
		let newSize = currentSize + 2n

		ensureCapacity(newSize, builder)

		let dstPtr = WasmI32.fromGrain(builder.buffer) + _BYTES_VALUE_OFFSET + currentSize

		let high = ((codePoint >>> 6n) & 0x1Fn) | 0xC0n
		let low = (codePoint & 0x3Fn) | 0x08n
		WasmI32.store8(dstPtr, high, 0n)
		WasmI32.store8(dstPtr + 1n, low, 0n)
		
		builder.size = tagSimpleNumber(newSize)
	} else if (codePoint <= 0xFFFFn) {
		let newSize = currentSize + 3n

		ensureCapacity(newSize, builder)

		let dstPtr = WasmI32.fromGrain(builder.buffer) + _BYTES_VALUE_OFFSET + currentSize

		let high = ((codePoint >>> 12n) & 0x0Fn) | 0xE0n
		let mid = ((codePoint >>> 6n) & 0x3Fn) | 0x80n
		let low = (codePoint & 0x3Fn) | 0x80n
		WasmI32.store8(dstPtr, high, 0n)
		WasmI32.store8(dstPtr + 1n, mid, 0n)
		WasmI32.store8(dstPtr + 2n, low, 0n)
		
		builder.size = tagSimpleNumber(newSize)
	} else if (codePoint <= 0x10FFFFn) {
		let newSize = currentSize + 4n

		ensureCapacity(newSize, builder)

		let dstPtr = WasmI32.fromGrain(builder.buffer) + _BYTES_VALUE_OFFSET + currentSize

		let high = ((codePoint >>> 18n) & 0x07n) | 0xF0n
		let mid1 = ((codePoint >>> 12n) & 0x3Fn) | 0x80n
		let mid2 = ((codePoint >>> 6n) & 0x3Fn) | 0x80n
		let low = (codePoint & 0x3Fn) | 0x80n
		WasmI32.store8(dstPtr, high, 0n)
		WasmI32.store8(dstPtr + 1n, mid1, 0n)
		WasmI32.store8(dstPtr + 2n, mid2, 0n)
		WasmI32.store8(dstPtr + 3n, low, 0n)
		
		builder.size = tagSimpleNumber(newSize)
	} else {
		throw InvalidArgument("Invalid character code")
	}
}

export let toString = (builder: StringBuilder) => {
	String.decodeRange(builder.buffer, String.UTF8, 0, builder.size)
}

export let clear = (builder: StringBuilder) => {
	builder.size = 0
}

export let reset = (newCapacity: Number, builder: StringBuilder) => {
	builder.size = 0
	builder.capacity = newCapacity
	builder.buffer = Bytes.make(newCapacity)
}
