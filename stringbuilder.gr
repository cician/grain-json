import Exception from "runtime/exception"
import Bytes from "bytes"
import WasmI32 from "runtime/unsafe/wasmi32"
import String from "string"
import Stubs from "stubs"

export record StringBuilder {
	mut size: Number,
	mut capacity: Number,
	growthFunction: (Number, Number) -> Number,
	mut buffer: Bytes
}

let defaultGrowthFunction = (currentCapacity: Number, newRequiredCapacity: Number) => {
	// The idea is to grow the size exponentially to quickly adapt in situations with
	// many small writes, but only up to a certain point because after that the risk
	// is to saturate overall available memory. After that .
	// In a WASM64 context different decisions can be made.

	if (currentCapacity < 104857600) { // arbitrary limit of 100MiB
		currentCapacity + currentCapacity * 2
	} else {
		currentCapacity + 1048576 // arbitrary increment of 1MiB
	}
}

export let makeWithGrowthFunction = (initialCapacity: Number, growthFunction: (Number, Number) -> Number) => {
	if (initialCapacity <= 0)
		throw Exception.InvalidArgument("initialCapacity must be a positive natural number")

	{
		size: 0,
		capacity: initialCapacity,
		growthFunction: growthFunction,
		buffer: Bytes.make(initialCapacity)
	}: StringBuilder
}

export let make = (initialCapacity: Number) => makeWithGrowthFunction(initialCapacity, defaultGrowthFunction);

let growIfNeeded = (newSize: Number, builder: StringBuilder) => {
	let growthFunction = builder.growthFunction
	let currentSize = builder.size
	let currentCapacity = builder.capacity

	let newGrowthCapacity = growthFunction(currentCapacity, newSize)

	let newCapacity =
		if (newGrowthCapacity >= newSize && newGrowthCapacity > 0) {
			newGrowthCapacity
		 } else {
			newSize
		 }
	
	if (newCapacity > currentCapacity) {
		//print ("newCapacity: " ++ toString(newCapacity))

		// create a new buffer with 
		let oldBuffer = builder.buffer
		let newBuffer = Bytes.make(newCapacity)
		Bytes.move(0, 0, currentSize, oldBuffer, newBuffer)
		builder.capacity = newCapacity
		builder.buffer = newBuffer
	}
}

let ensureFreeCapacity = (size: Number, builder: StringBuilder) => {
	let currentSize = builder.size
	let currentCapacity = builder.capacity

	let newSize = currentSize + size

	// resize if necessary
	if (currentCapacity < newSize)
		growIfNeeded(newSize, builder)
}

export let append = (s: String, builder: StringBuilder) => {
	let srcStrPtr = WasmI32.fromGrain(s)
	let bytesToWrite = String.byteLength(s)

	let currentSize = builder.size

	let newSize = currentSize + bytesToWrite

	// resize if necessary
	ensureFreeCapacity(bytesToWrite, builder)

	// Copy the string's content in the buffer offset by current size.
	let bytesWritten = Stubs.writeStringToBytesAsUTF8(currentSize, s, builder.buffer)
	// assert(bytesWritten == bytesToWrite)

	// Could replace the stub above with this function recently added to stdlib, but
	// it's slightly slower because it works bytes by byte even for UTF8.
	//String.encodeAt(s, String.UTF8, builder.buffer, currentSize)

	builder.size = newSize
}

export let appendChar = (c: Char, builder: StringBuilder) => {
	let currentSize = builder.size
	let currentCapacity = builder.capacity

	if (currentSize + 4 <= currentCapacity) {
		// Add a branch, but avoid a few checks for the most common case of the char fitting into the buffer.
		// This case of the branch should be used for most calls to appendChar because of exponential allocation of the buffer.
		let bytesWritten = Stubs.writeCharToBytesAsUTF8(currentSize, c, builder.buffer)
		
		let newSize = currentSize + bytesWritten

		builder.size = newSize
	} else {
		// Technically this gets computed two times. Here and in writeCharToBytesAsUTF8.
		// If we want to avoid calculating it two times there are two choices:
		// a) Just make sure there are always 4 free bytes in the buffer.
		// b) Incorporate the content of writeCharToBytesAsUTF8 here.
		let bytesToWrite = Stubs.charUTF8SizeInBytes(c)

		// resize if necessary
		ensureFreeCapacity(bytesToWrite, builder)
		// ensureFreeCapacity(4, builder)

		let bytesWritten = Stubs.writeCharToBytesAsUTF8(currentSize, c, builder.buffer)
		// assert(bytesWritten == bytesToWrite)

		let newSize = currentSize + bytesWritten

		builder.size = newSize
	}
}

export let appendUnicodeCodePoint = (code: Number, builder: StringBuilder) => {
	let currentSize = builder.size
	let currentCapacity = builder.capacity

	if (currentSize + 4 <= currentCapacity) {
		let bytesWritten = Stubs.writeUnicodeCodePointToBytesAsUTF8(currentSize, code, builder.buffer)
		//assert(bytesWritten == bytesToWrite)

		let newSize = currentSize + bytesWritten

		builder.size = newSize
	} else {
		let bytesToWrite = Stubs.numberOfBytesForUTF8CodePoint(code)

		//resize if necessary
		ensureFreeCapacity(bytesToWrite, builder)
		// ensureFreeCapacity(4, builder)

		let bytesWritten = Stubs.writeUnicodeCodePointToBytesAsUTF8(currentSize, code, builder.buffer)
		// assert(bytesWritten == bytesToWrite)

		let newSize = currentSize + bytesWritten

		builder.size = newSize
	}
}

export let toString = (builder: StringBuilder) => {
	// FIXME String.decodeRange hangs for small buffer size
	// append("rgergrge43n2tssrs", builder)
	String.decodeRange(builder.buffer, String.UTF8, 0, builder.size)
}

export let clear = (builder: StringBuilder) => {
	builder.size = 0
}

export let reset = (newCapacity: Number, builder: StringBuilder) => {
	builder.size = 0
	builder.capacity = newCapacity
	builder.buffer = Bytes.make(newCapacity)
}
